
/*  A Bison parser, made from idlparser.y
 by  GNU Bison version 1.25
  */

#define YYBISON 1  /* Identify Bison output.  */

#define yyparse idlparse
#define yylex idllex
#define yyerror idlerror
#define yylval idllval
#define yychar idlchar
#define yydebug idldebug
#define yynerrs idlnerrs
#define	IDENT	258
#define	BOOL_FALSE	259
#define	BOOL_TRUE	260
#define	CHAR_L	261
#define	FLOAT_L	262
#define	INTEGER_L	263
#define	STRING_L	264
#define	FIXED_PT_L	265
#define	ONEWAY	266
#define	VOID_T	267
#define	IN	268
#define	OUT	269
#define	INOUT	270
#define	PRAGMA_ID	271
#define	PRAGMA_VERSION	272
#define	PRAGMA_PREFIX	273
#define	ANY_T	274
#define	ATTRIBUTE	275
#define	BOOLEAN_T	276
#define	CASE	277
#define	CHAR_T	278
#define	CONST	279
#define	CONTEXT	280
#define	DEFAULT	281
#define	DOUBLE_T	282
#define	ENUM	283
#define	EXCEPTION	284
#define	FIXED	285
#define	FLOAT_T	286
#define	INTERFACE	287
#define	LONG_T	288
#define	LSHIFT	289
#define	MODULE	290
#define	OBJECT_T	291
#define	NATIVE	292
#define	OCTET_T	293
#define	RAISES	294
#define	READONLY	295
#define	RSHIFT	296
#define	SCOPE	297
#define	SEQUENCE	298
#define	SHORT_T	299
#define	STRING_T	300
#define	STRUCT	301
#define	SWITCH	302
#define	TYPEDEF	303
#define	UNION	304
#define	UNSIGNED_T	305
#define	WCHAR_T	306
#define	WSTRING_T	307
#define	ABSTRACT	308
#define	CUSTOM	309
#define	FACTORY	310
#define	PRIVATE	311
#define	PUBLIC	312
#define	SUPPORTS	313
#define	TRUNCATABLE	314
#define	VALUEBASE	315
#define	VALUETYPE	316

#line 73 "idlparser.y"

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#ifndef STANDALONE
#include <iluptype.h>
#endif
#include "iluidl.h"

#if (defined(WIN32) || defined(WIN16))
#include <malloc.h>	/* needed because of include of alloca */
#endif

/* tunable parameters. For 2.0a10 compatibility, all should be 0 */
#define LOCAL_TYPES_HAVE_REP_IDS  1

/* Make the Bison parser produce better error messages */
#define YYERROR_VERBOSE
#include "idlparser-output.c"

  /* missing prototypes */
int yylex(void);
#ifndef STANDALONE
void FigureTypeUID(Type t);
#endif

#define ADD_PRIMITIVE_TYPES  \
  ADD_PRIMITIVE_TYPE (void)\
  ADD_PRIMITIVE_TYPE (short)\
  ADD_PRIMITIVE_TYPE (long)\
  ADD_PRIMITIVE_TYPE (long_long)\
  ADD_PRIMITIVE_TYPE (float)\
  ADD_PRIMITIVE_TYPE (double)\
  ADD_PRIMITIVE_TYPE (unsigned_short)\
  ADD_PRIMITIVE_TYPE (unsigned_long)\
  ADD_PRIMITIVE_TYPE (unsigned_long_long)\
  ADD_PRIMITIVE_TYPE (octet)\
  ADD_PRIMITIVE_TYPE (boolean)\
  ADD_PRIMITIVE_TYPE (char)\
  ADD_PRIMITIVE_TYPE (wchar)\
  ADD_PRIMITIVE_TYPE (object)\
  ADD_PRIMITIVE_TYPE (valuebase)\
  ADD_PRIMITIVE_TYPE (any)

#define ADD_PRIMITIVE_TYPE(x)  IDLType the_##x##_t;
ADD_PRIMITIVE_TYPES
#undef ADD_PRIMITIVE_TYPE

#ifndef STANDALONE
Type the_CORBA_Object;
static Interface the_ilu_module;
static Type the_ilu_CString;
#endif
static IDLType the_string_t;
static IDLType the_fixed_t;
static int next_serial=0;

list the_result=0;
int idl_subset = IDL_OBV;


#line 136 "idlparser.y"
typedef union{
  refany any; /*unspecified*/
  IDLDefinition definition;
  list definition_list;
  IDLName name;
  list name_list;
  IDLValue value;
  IDLType type;
  boolean flag;
  list string_list;
  list caselabel_list;
  ArgDirection inout;
  char opname;
  IDLCase caselabel;
} YYSTYPE;
#ifndef YYDEBUG
#define YYDEBUG 1
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		365
#define	YYFLAG		-32768
#define	YYNTBASE	83

#define YYTRANSLATE(x) ((unsigned)(x) <= 316 ? yytranslate[x] : 194)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,    77,    72,     2,    67,
    68,    75,    73,    66,    74,     2,    76,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    65,    62,    79,
    69,    80,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    81,     2,    82,    71,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    63,    70,    64,    78,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     5,     8,    11,    14,    17,    20,    22,    28,
    30,    33,    35,    37,    42,    46,    47,    49,    53,    59,
    60,    62,    65,    68,    71,    74,    77,    79,    82,    84,
    87,    91,    93,    97,    99,   101,   103,   105,   108,   112,
   116,   124,   129,   133,   138,   140,   144,   145,   149,   150,
   152,   153,   156,   158,   160,   162,   167,   169,   171,   178,
   179,   181,   183,   187,   191,   197,   199,   201,   203,   205,
   207,   209,   211,   213,   215,   217,   219,   221,   225,   227,
   231,   233,   237,   239,   243,   247,   249,   253,   257,   259,
   263,   267,   271,   274,   276,   278,   280,   282,   284,   286,
   290,   292,   294,   296,   298,   300,   302,   304,   306,   308,
   310,   313,   316,   318,   320,   322,   325,   328,   330,   332,
   334,   336,   338,   340,   342,   344,   346,   348,   350,   352,
   354,   356,   358,   360,   362,   364,   366,   368,   370,   372,
   376,   378,   380,   382,   384,   386,   388,   390,   392,   394,
   396,   398,   401,   403,   405,   407,   409,   411,   415,   418,
   421,   423,   425,   427,   429,   431,   433,   435,   441,   443,
   446,   450,   460,   462,   464,   466,   468,   470,   472,   474,
   476,   479,   483,   485,   488,   492,   495,   498,   504,   506,
   510,   512,   519,   524,   529,   531,   536,   538,   541,   544,
   548,   553,   557,   558,   560,   566,   567,   569,   576,   577,
   579,   581,   583,   587,   590,   592,   596,   600,   602,   604,
   606,   607,   612,   613,   618,   620,   624,   626,   628,   630,
   632,   634,   641,   643,   645,   647
};

static const short yyrhs[] = {    86,
     0,   130,    62,     0,   114,    62,     0,   178,    62,     0,
    87,    62,     0,    85,    62,     0,    97,    62,     0,   193,
     0,    35,     3,    63,    86,    64,     0,    84,     0,    86,
    84,     0,    88,     0,    89,     0,    91,    63,    92,    64,
     0,    90,    32,     3,     0,     0,    53,     0,    90,    32,
     3,     0,    90,    32,     3,    65,    96,     0,     0,    94,
     0,   130,    62,     0,   114,    62,     0,   178,    62,     0,
   176,    62,     0,   180,    62,     0,    93,     0,    94,    93,
     0,     3,     0,    42,     3,     0,    95,    42,     3,     0,
    95,     0,    96,    66,    95,     0,   101,     0,   100,     0,
    99,     0,    98,     0,    61,     3,     0,    53,    61,     3,
     0,    61,     3,   132,     0,    53,    61,     3,   103,    63,
    92,    64,     0,   102,    63,   106,    64,     0,    61,     3,
   103,     0,    54,    61,     3,   103,     0,   104,     0,   104,
    58,    96,     0,     0,    65,   105,    96,     0,     0,    59,
     0,     0,   106,   107,     0,    93,     0,   108,     0,   110,
     0,   109,   132,   137,    62,     0,    56,     0,    57,     0,
    55,     3,    67,   111,    68,    62,     0,     0,   112,     0,
   113,     0,   112,    66,   113,     0,    13,   190,   139,     0,
    24,   115,     3,    69,   116,     0,   142,     0,   151,     0,
   152,     0,   153,     0,   154,     0,   141,     0,   172,     0,
   173,     0,   192,     0,    95,     0,   117,     0,   118,     0,
   117,    70,   118,     0,   119,     0,   118,    71,   119,     0,
   120,     0,   119,    72,   120,     0,   121,     0,   120,    34,
   121,     0,   120,    41,   121,     0,   122,     0,   121,    73,
   122,     0,   121,    74,   122,     0,   123,     0,   122,    75,
   123,     0,   122,    76,   123,     0,   122,    77,   123,     0,
   124,   125,     0,   125,     0,    73,     0,    74,     0,    78,
     0,    95,     0,   126,     0,    67,   116,    68,     0,     8,
     0,   129,     0,     6,     0,    10,     0,     7,     0,   127,
     0,     5,     0,     4,     0,   116,     0,     9,     0,   129,
     9,     0,    48,   131,     0,   158,     0,   161,     0,   168,
     0,    37,   139,     0,   132,   137,     0,   133,     0,   136,
     0,   134,     0,   135,     0,    95,     0,   141,     0,   142,
     0,   151,     0,   152,     0,   153,     0,   154,     0,   156,
     0,   155,     0,   157,     0,   171,     0,   172,     0,   173,
     0,   191,     0,   158,     0,   161,     0,   168,     0,   138,
     0,   137,    66,   138,     0,   139,     0,   140,     0,     3,
     0,   174,     0,    31,     0,    27,     0,   143,     0,   147,
     0,   145,     0,   146,     0,   144,     0,    33,    33,     0,
    33,     0,    44,     0,   149,     0,   150,     0,   148,     0,
    50,    33,    33,     0,    50,    33,     0,    50,    44,     0,
    23,     0,    51,     0,    21,     0,    38,     0,    19,     0,
    36,     0,    60,     0,    46,     3,    63,   159,    64,     0,
   160,     0,   159,   160,     0,   132,   137,    62,     0,    49,
     3,    47,    67,   162,    68,    63,   163,    64,     0,   142,
     0,   151,     0,   152,     0,   153,     0,   154,     0,   168,
     0,    95,     0,   164,     0,   163,   164,     0,   165,   167,
    62,     0,   166,     0,   165,   166,     0,    22,   116,    65,
     0,    26,    65,     0,   132,   138,     0,    28,     3,    63,
   169,    64,     0,   170,     0,   169,    66,   170,     0,     3,
     0,    43,    79,   133,    66,   128,    80,     0,    43,    79,
   133,    80,     0,    45,    79,   128,    80,     0,    45,     0,
    52,    79,   128,    80,     0,    52,     0,     3,   175,     0,
   174,   175,     0,    81,   128,    82,     0,   177,    20,   190,
   139,     0,   176,    66,   139,     0,     0,    40,     0,    29,
     3,    63,   179,    64,     0,     0,   159,     0,   181,   182,
     3,   183,   187,   188,     0,     0,    11,     0,   190,     0,
    12,     0,    67,   184,    68,     0,    67,    68,     0,   185,
     0,   184,    66,   185,     0,   186,   190,   139,     0,    13,
     0,    14,     0,    15,     0,     0,    39,    67,    96,    68,
     0,     0,    25,    67,   189,    68,     0,   129,     0,   189,
    66,   129,     0,   134,     0,   172,     0,   173,     0,   191,
     0,    95,     0,    30,    79,   128,    66,   128,    80,     0,
    30,     0,    17,     0,    16,     0,    18,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   208,   210,   211,   212,   213,   214,   215,   216,   219,   225,
   227,   233,   234,   236,   241,   247,   248,   250,   258,   268,
   269,   271,   272,   273,   274,   275,   277,   282,   286,   287,
   288,   291,   295,   300,   301,   302,   303,   305,   312,   321,
   332,   341,   346,   351,   358,   362,   367,   373,   381,   383,
   386,   388,   393,   394,   395,   397,   405,   406,   408,   418,
   420,   422,   426,   431,   440,   448,   449,   450,   451,   452,
   453,   454,   455,   456,   457,   462,   463,   464,   467,   468,
   471,   472,   474,   475,   477,   479,   480,   482,   484,   485,
   487,   489,   491,   492,   493,   494,   495,   496,   500,   501,
   502,   503,   504,   505,   506,   507,   509,   509,   510,   512,
   513,   526,   527,   528,   529,   530,   536,   542,   543,   549,
   550,   551,   556,   557,   558,   559,   560,   561,   562,   563,
   564,   566,   567,   568,   569,   571,   572,   573,   575,   579,
   582,   583,   585,   586,   588,   589,   592,   593,   595,   596,
   597,   598,   599,   600,   602,   603,   604,   605,   606,   607,
   609,   610,   611,   612,   613,   614,   615,   617,   626,   628,
   630,   636,   648,   649,   650,   651,   652,   653,   655,   659,
   661,   664,   667,   669,   672,   674,   677,   683,   690,   692,
   694,   703,   708,   714,   716,   719,   721,   724,   728,   731,
   733,   740,   750,   751,   753,   758,   759,   761,   772,   773,
   775,   776,   778,   779,   782,   784,   787,   794,   795,   796,
   798,   799,   801,   802,   804,   806,   809,   810,   811,   812,
   813,   818,   824,   826,   827,   828
};
#endif


#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)

static const char * const yytname[] = {   "$","error","$undefined.","IDENT",
"BOOL_FALSE","BOOL_TRUE","CHAR_L","FLOAT_L","INTEGER_L","STRING_L","FIXED_PT_L",
"ONEWAY","VOID_T","IN","OUT","INOUT","PRAGMA_ID","PRAGMA_VERSION","PRAGMA_PREFIX",
"ANY_T","ATTRIBUTE","BOOLEAN_T","CASE","CHAR_T","CONST","CONTEXT","DEFAULT",
"DOUBLE_T","ENUM","EXCEPTION","FIXED","FLOAT_T","INTERFACE","LONG_T","LSHIFT",
"MODULE","OBJECT_T","NATIVE","OCTET_T","RAISES","READONLY","RSHIFT","SCOPE",
"SEQUENCE","SHORT_T","STRING_T","STRUCT","SWITCH","TYPEDEF","UNION","UNSIGNED_T",
"WCHAR_T","WSTRING_T","ABSTRACT","CUSTOM","FACTORY","PRIVATE","PUBLIC","SUPPORTS",
"TRUNCATABLE","VALUEBASE","VALUETYPE","';'","'{'","'}'","':'","','","'('","')'",
"'='","'|'","'^'","'&'","'+'","'-'","'*'","'/'","'%'","'~'","'<'","'>'","'['",
"']'","specification","definition","module","definition_list","interface","interface_dcl",
"forward_dcl","opt_abstract","interface_header","interface_body","export","export_list",
"scoped_name","scoped_name_list","value","value_forward_dcl","value_box_dcl",
"value_abs_dcl","value_dcl","value_header","opt_value_inheritance_spec","opt_value_inheritance_base",
"opt_truncatable","value_element_list","value_element","state_member","private_public",
"init_dcl","opt_init_param_dcl_list","init_param_dcl_list","init_param_dcl",
"const_dcl","const_type","const_expr","or_expr","xor_expr","and_expr","shift_expr",
"add_expr","mult_expr","unary_expr","unary_operator","primary_expr","literal",
"boolean_literal","positive_const_int","string_literal","type_dcl","type_declarator",
"type_spec","simple_type_spec","base_type_spec","template_type_spec","constr_type_spec",
"declarators","declarator","simple_declarator","complex_declarator","floating_pt_type",
"integer_type","signed_int","signed_long_long_int","signed_long_int","signed_short_int",
"unsigned_int","unsigned_long_long_int","unsigned_long_int","unsigned_short_int",
"char_type","wide_char_type","boolean_type","octet_type","any_type","object_type",
"value_base_type","struct_type","member_list","member","union_type","switch_type_spec",
"switch_body","case","case_label_list","case_label","element_spec","enum_type",
"enumerator_list","enumerator","sequence_type","string_type","wide_string_type",
"array_declarator","fixed_array_size","attr_dcl","opt_readonly","except_dcl",
"opt_member_list","op_dcl","opt_op_attr","op_type_spec","parameter_dcls","param_dcl_list",
"param_dcl","param_attribute","opt_raises_expr","opt_context_expr","string_literal_list",
"param_type_spec","fixed_pt_type","fixed_pt_const_type","pragma", NULL
};
#endif

static const short yyr1[] = {     0,
    83,    84,    84,    84,    84,    84,    84,    84,    85,    86,
    86,    87,    87,    88,    89,    90,    90,    91,    91,    92,
    92,    93,    93,    93,    93,    93,    94,    94,    95,    95,
    95,    96,    96,    97,    97,    97,    97,    98,    98,    99,
   100,   101,   102,   102,   103,   103,   104,   104,   105,   105,
   106,   106,   107,   107,   107,   108,   109,   109,   110,   111,
   111,   112,   112,   113,   114,   115,   115,   115,   115,   115,
   115,   115,   115,   115,   115,   116,   117,   117,   118,   118,
   119,   119,   120,   120,   120,   121,   121,   121,   122,   122,
   122,   122,   123,   123,   124,   124,   124,   125,   125,   125,
   126,   126,   126,   126,   126,   126,   127,   127,   128,   129,
   129,   130,   130,   130,   130,   130,   131,   132,   132,   133,
   133,   133,   134,   134,   134,   134,   134,   134,   134,   134,
   134,   135,   135,   135,   135,   136,   136,   136,   137,   137,
   138,   138,   139,   140,   141,   141,   142,   142,   143,   143,
   143,   144,   145,   146,   147,   147,   147,   148,   149,   150,
   151,   152,   153,   154,   155,   156,   157,   158,   159,   159,
   160,   161,   162,   162,   162,   162,   162,   162,   162,   163,
   163,   164,   165,   165,   166,   166,   167,   168,   169,   169,
   170,   171,   171,   172,   172,   173,   173,   174,   174,   175,
   176,   176,   177,   177,   178,   179,   179,   180,   181,   181,
   182,   182,   183,   183,   184,   184,   185,   186,   186,   186,
   187,   187,   188,   188,   189,   189,   190,   190,   190,   190,
   190,   191,   192,   193,   193,   193
};

static const short yyr2[] = {     0,
     1,     2,     2,     2,     2,     2,     2,     1,     5,     1,
     2,     1,     1,     4,     3,     0,     1,     3,     5,     0,
     1,     2,     2,     2,     2,     2,     1,     2,     1,     2,
     3,     1,     3,     1,     1,     1,     1,     2,     3,     3,
     7,     4,     3,     4,     1,     3,     0,     3,     0,     1,
     0,     2,     1,     1,     1,     4,     1,     1,     6,     0,
     1,     1,     3,     3,     5,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     3,     1,     3,
     1,     3,     1,     3,     3,     1,     3,     3,     1,     3,
     3,     3,     2,     1,     1,     1,     1,     1,     1,     3,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     2,     2,     1,     1,     1,     2,     2,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     3,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     2,     1,     1,     1,     1,     1,     3,     2,     2,
     1,     1,     1,     1,     1,     1,     1,     5,     1,     2,
     3,     9,     1,     1,     1,     1,     1,     1,     1,     1,
     2,     3,     1,     2,     3,     2,     2,     5,     1,     3,
     1,     6,     4,     4,     1,     4,     1,     2,     2,     3,
     4,     3,     0,     1,     5,     0,     1,     6,     0,     1,
     1,     1,     3,     2,     1,     3,     3,     1,     1,     1,
     0,     4,     0,     4,     1,     3,     1,     1,     1,     1,
     1,     6,     1,     1,     1,     1
};

static const short yydefact[] = {    16,
   235,   234,   236,     0,     0,     0,     0,     0,     0,     0,
     0,    17,     0,     0,    10,     0,     1,     0,    12,    13,
     0,     0,     0,    37,    36,    35,    34,     0,     0,     0,
   113,   114,   115,     0,     8,    29,   163,   161,   146,   233,
   145,   153,   164,     0,   154,   195,     0,   162,   197,    75,
     0,    71,    66,   147,   151,   149,   150,   148,   157,   155,
   156,    67,    68,    69,    70,    72,    73,    74,     0,     0,
     0,   143,   116,     0,   165,     0,   166,     0,   167,   122,
   112,     0,   118,   120,   121,   119,   123,   124,   125,   126,
   127,   128,   130,   129,   131,   136,   137,   138,   132,   133,
   134,   135,     0,     0,     0,    47,     6,    11,     5,     0,
   209,     7,    51,     3,     2,     4,   152,    30,     0,   159,
   160,     0,     0,     0,     0,   206,    16,     0,     0,     0,
   143,   117,   139,   141,   142,   144,     0,    47,    47,    49,
    43,    45,    40,    15,   210,   204,     0,    27,   209,     0,
     0,     0,     0,     0,     0,     0,   209,   108,   107,   103,
   105,   101,   110,   104,     0,    95,    96,    97,    98,   109,
    76,    77,    79,    81,    83,    86,    89,     0,    94,    99,
   106,     0,   102,   158,     0,    31,     0,   191,     0,   189,
     0,   207,   169,     0,    16,     0,     0,     0,     0,   198,
     0,   199,     0,     0,    44,    50,     0,     0,     0,    14,
    28,    23,    22,    25,     0,     0,    24,    26,   212,   231,
   227,   228,   229,     0,   211,   230,     0,    57,    58,    42,
    53,    52,    54,     0,    55,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,    93,   194,   111,   196,
    65,   188,     0,     0,   170,   205,     9,   168,     0,     0,
   193,     0,   140,   179,   173,   174,   175,   176,   177,     0,
   178,   209,    32,    48,    46,    19,   202,     0,     0,     0,
     0,   100,    78,    80,    82,    84,    85,    87,    88,    90,
    91,    92,   190,   171,     0,     0,   200,     0,     0,     0,
   201,     0,   221,    60,     0,   232,   192,     0,    41,    33,
   218,   219,   220,   214,     0,   215,     0,     0,   223,     0,
     0,    61,    62,    56,     0,     0,     0,   180,     0,   183,
     0,   213,     0,     0,     0,   208,     0,     0,     0,     0,
   186,   172,   181,     0,   184,     0,   216,   217,     0,     0,
    64,    59,    63,   185,   187,   182,   222,   225,     0,     0,
   224,   226,     0,     0,     0
};

static const short yydefgoto[] = {   363,
    15,    16,    17,    18,    19,    20,    21,    22,   147,   148,
   149,   169,   274,    23,    24,    25,    26,    27,    28,   141,
   142,   207,   157,   232,   233,   234,   235,   321,   322,   323,
    29,    51,   170,   171,   172,   173,   174,   175,   176,   177,
   178,   179,   180,   181,   182,   183,    30,    81,   191,    83,
    84,    85,    86,   132,   133,   134,   135,    87,    88,    54,
    55,    56,    57,    58,    59,    60,    61,    89,    90,    91,
    92,    93,    94,    95,    31,   192,   193,    32,   270,   327,
   328,   329,   330,   346,    33,   189,   190,    99,   100,   101,
   136,   200,   152,   153,    34,   194,   155,   156,   224,   303,
   315,   316,   317,   319,   336,   359,   225,   102,    68,    35
};

static const short yypact[] = {   658,
-32768,-32768,-32768,   563,    78,    89,    95,    98,   131,   394,
   138,    81,    82,   141,-32768,    83,   635,    84,-32768,-32768,
   115,    85,    87,-32768,-32768,-32768,-32768,    88,    91,    92,
-32768,-32768,-32768,    93,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   123,-32768,   155,-32768,    80,    19,-32768,    86,   120,
   160,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   103,   104,
   107,-32768,-32768,   112,-32768,    97,-32768,    99,-32768,   120,
-32768,   174,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,   137,   182,   183,   216,-32768,-32768,-32768,   187,
   260,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    40,   158,
-32768,    40,   192,   128,   195,   394,   658,   394,    40,   428,
   121,   135,-32768,-32768,-32768,   121,   139,    31,   142,   154,
-32768,   157,-32768,     6,-32768,-32768,   156,-32768,   539,   159,
   161,    21,   198,   162,   164,   462,   525,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,    40,-32768,-32768,-32768,   120,-32768,
   152,   163,   168,     0,   -37,   -22,-32768,    69,-32768,-32768,
-32768,   149,   223,-32768,   153,-32768,    40,-32768,    63,-32768,
   174,   394,-32768,   172,   582,   316,   175,   -40,    40,-32768,
   174,-32768,   606,   179,-32768,-32768,    25,    25,    25,-32768,
-32768,-32768,-32768,-32768,    98,   496,-32768,-32768,-32768,   120,
-32768,-32768,-32768,   242,-32768,-32768,   245,-32768,-32768,-32768,
-32768,-32768,-32768,   394,-32768,   185,    40,    40,    40,    40,
    40,    40,    40,    40,    40,    40,-32768,-32768,-32768,-32768,
-32768,-32768,   195,    22,-32768,-32768,-32768,-32768,    40,    40,
-32768,   169,-32768,   120,-32768,-32768,-32768,-32768,-32768,   188,
-32768,   260,   120,   184,   184,   184,-32768,    98,   190,   196,
   174,-32768,   163,   168,     0,   -37,   -37,   -22,   -22,-32768,
-32768,-32768,-32768,-32768,   189,   193,-32768,   201,   191,    25,
-32768,    18,   231,   261,    23,-32768,-32768,    68,-32768,   120,
-32768,-32768,-32768,-32768,    67,-32768,   496,   208,   252,   496,
   211,   217,-32768,-32768,    40,   220,    16,-32768,   360,-32768,
    47,-32768,    98,    25,   215,-32768,    98,   224,   261,   222,
-32768,-32768,-32768,   174,-32768,   228,-32768,-32768,    71,   282,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,   223,    72,   282,
-32768,   223,   292,   293,-32768
};

static const short yypgoto[] = {-32768,
   -13,-32768,   167,-32768,-32768,-32768,-32768,-32768,    26,   -98,
-32768,    -4,  -184,-32768,-32768,-32768,-32768,-32768,-32768,   -30,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   -44,
   -93,-32768,  -152,-32768,    62,    64,    65,  -125,  -122,  -140,
-32768,   125,-32768,-32768,   -99,  -321,   -92,-32768,    -7,   171,
  -148,-32768,-32768,  -169,  -180,    -6,-32768,   301,     5,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,     7,     8,    11,
    13,-32768,-32768,-32768,    -3,   186,  -101,     4,-32768,-32768,
   -20,-32768,   -19,-32768,    -9,-32768,    58,-32768,     1,    12,
-32768,   176,-32768,-32768,   -91,-32768,-32768,-32768,-32768,-32768,
-32768,   -16,-32768,-32768,-32768,-32768,  -189,  -146,-32768,-32768
};


#define	YYLAST		719


static const short yytable[] = {    50,
    98,    73,    82,   108,    66,    80,    96,   221,    53,   226,
    62,    63,   236,    97,    64,    67,    65,   150,   151,   154,
   263,   254,   185,   275,   276,   260,   278,    36,   358,   197,
   311,   312,   313,   240,   251,   242,   243,   325,   362,   261,
   241,   326,    36,   158,   159,   160,   161,   162,   163,   164,
   211,   120,   244,   245,   246,   150,   151,   154,   231,   311,
   312,   313,   121,   150,   151,   154,    44,   221,   -18,   226,
   209,    36,   158,   159,   160,   161,   162,   163,   164,   342,
    69,    44,   214,   294,   324,   314,   215,   201,   201,   325,
   255,    70,   -39,   326,   255,   140,    98,    71,   143,   262,
    72,    80,    96,   290,   291,   292,   165,   204,   205,    97,
    44,   305,   166,   167,   286,   287,    98,   168,    98,   288,
   289,    80,    96,    80,    96,    80,   252,   333,   253,    97,
   337,    97,   331,    74,   332,   165,   300,   360,   357,   361,
   103,   104,   105,   106,   107,   109,   110,   111,   112,   349,
   113,   220,   114,   115,   116,   117,   222,   118,   119,   295,
   296,   123,   124,   355,   122,   125,   126,   223,   221,   127,
   226,   221,   340,   226,   128,   129,   131,   130,   150,   151,
   154,   108,    98,   137,   138,   139,    98,    80,    96,   144,
   184,    80,    96,   271,   186,    97,   187,   188,   264,    97,
   201,   199,   273,   273,   273,   203,   140,   265,   277,   266,
   267,   220,   206,   268,   208,   269,   222,   216,    36,   210,
   212,   237,   213,   217,    98,   218,   281,   223,   248,    80,
    96,   249,   250,   238,    75,   256,    37,    97,    38,   239,
   259,   272,    39,     5,   279,    76,    41,   280,    42,   300,
   297,    77,   282,    43,   309,   298,   302,    44,    78,    45,
    46,     9,   304,   308,    11,    47,    48,    49,   306,   318,
   145,   301,   307,   320,   334,    79,   335,   -38,   338,  -203,
   140,   350,   339,     4,   341,   352,   354,     5,     6,   356,
   163,   364,   365,   195,   353,   310,     8,   299,   283,   146,
   198,   284,   247,   285,    52,     9,   343,    10,    11,   345,
   293,   202,   220,   196,   347,   220,     0,   222,    36,    98,
   222,   344,     0,   -20,    80,    96,   348,     0,   223,   273,
   351,   223,    97,     0,    75,     0,    37,     0,    38,     0,
     0,     0,    39,     5,     0,    76,    41,     0,    42,     0,
     0,    77,     0,    43,     0,     0,     0,    44,    78,    45,
    46,     9,    36,     0,    11,    47,    48,    49,     0,     0,
     0,     0,     0,     0,     0,    79,     0,     0,    75,   258,
    37,   325,    38,     0,     0,   326,    39,     5,     0,    76,
    41,     0,    42,     0,     0,    77,    36,    43,     0,     0,
     0,    44,    78,    45,    46,     9,     0,     0,    11,    47,
    48,    49,    75,     0,    37,     0,    38,     0,     0,    79,
    39,     5,     0,    76,    41,     0,    42,     0,     0,    77,
    36,    43,     0,     0,     0,    44,    78,    45,    46,     9,
     0,     0,    11,    47,    48,    49,    75,     0,    37,     0,
    38,     0,     0,    79,    39,     0,     0,    76,    41,     0,
    42,     0,     0,    77,    36,    43,     0,     0,     0,    44,
    78,    45,    46,   219,     0,     0,     0,    47,    48,    49,
    75,     0,    37,     0,    38,     0,     0,    79,    39,     0,
     0,    76,    41,     0,    42,     0,     0,    77,    36,    43,
     0,     0,     0,    44,     0,    45,    46,     0,     0,     0,
     0,    47,    48,    49,    75,     0,    37,     0,    38,     0,
     0,    79,    39,     0,     0,    76,    41,     0,    42,     0,
     0,    77,     0,    43,     0,   145,     0,    44,     0,    45,
    46,     0,     0,     0,  -203,    47,    48,    49,     4,   145,
     0,     0,     5,     6,     0,    79,     0,     0,  -203,     0,
     0,     8,     4,     0,   146,    36,     5,     6,     0,     0,
     9,     0,    10,    11,     0,     8,     0,     0,   146,   227,
   228,   229,     0,    37,     9,    38,    10,    11,   230,    39,
     0,     0,    40,    41,     0,    42,     0,     1,     2,     3,
    43,     0,   -21,     0,    44,     4,    45,    46,    36,     5,
     6,     0,    47,    48,    49,     0,     7,     0,     8,     0,
     0,     0,     0,     0,     0,     0,    37,     9,    38,    10,
    11,     0,     0,     5,    12,    13,     0,     0,    42,     0,
     0,     0,    14,    43,     0,   257,     0,    44,     0,    45,
     1,     2,     3,     0,     0,    47,    48,     0,     4,     0,
     0,     0,     5,     6,     0,     0,   -16,     0,     0,     7,
     0,     8,     0,     1,     2,     3,     0,     0,     0,     0,
     9,     4,    10,    11,     0,     5,     6,    12,    13,     0,
     0,     0,     7,     0,     8,    14,     0,     0,     0,     0,
     0,     0,     0,     9,     0,    10,    11,     0,     0,     0,
    12,    13,     0,     0,     0,     0,     0,     0,    14
};

static const short yycheck[] = {     4,
    10,     8,    10,    17,     4,    10,    10,   156,     4,   156,
     4,     4,   165,    10,     4,     4,     4,   111,   111,   111,
   201,   191,   122,   208,   209,    66,   216,     3,   350,   129,
    13,    14,    15,    34,   187,    73,    74,    22,   360,    80,
    41,    26,     3,     4,     5,     6,     7,     8,     9,    10,
   149,    33,    75,    76,    77,   149,   149,   149,   157,    13,
    14,    15,    44,   157,   157,   157,    42,   216,    63,   216,
    65,     3,     4,     5,     6,     7,     8,     9,    10,    64,
     3,    42,    62,    62,    62,    68,    66,    66,    66,    22,
   192,     3,    62,    26,   196,    65,   106,     3,   106,   199,
     3,   106,   106,   244,   245,   246,    67,   138,   139,   106,
    42,   281,    73,    74,   240,   241,   126,    78,   128,   242,
   243,   126,   126,   128,   128,   130,    64,   317,    66,   126,
   320,   128,    66,     3,    68,    67,    66,    66,    68,    68,
     3,    61,    61,     3,    62,    62,    32,    63,    62,   334,
    63,   156,    62,    62,    62,    33,   156,     3,    79,   259,
   260,    42,     3,   344,    79,    63,    63,   156,   317,    63,
   317,   320,   325,   320,    63,    79,     3,    79,   272,   272,
   272,   195,   192,    47,     3,     3,   196,   192,   192,     3,
    33,   196,   196,   203,     3,   192,    69,     3,   203,   196,
    66,    81,   207,   208,   209,    67,    65,   203,   215,   203,
   203,   216,    59,   203,    58,   203,   216,    20,     3,    64,
    62,    70,    62,    62,   234,    62,   234,   216,    80,   234,
   234,     9,    80,    71,    19,    64,    21,   234,    23,    72,
    66,    63,    27,    28,     3,    30,    31,     3,    33,    66,
    82,    36,    68,    38,    64,    68,    67,    42,    43,    44,
    45,    46,    67,    63,    49,    50,    51,    52,    80,    39,
    11,   278,    80,    13,    67,    60,    25,    62,    68,    20,
    65,    67,    66,    24,    65,    62,    65,    28,    29,    62,
     9,     0,     0,   127,   339,   300,    37,   272,   237,    40,
   130,   238,   178,   239,     4,    46,   327,    48,    49,   329,
   253,   136,   317,   128,   331,   320,    -1,   317,     3,   329,
   320,   329,    -1,    64,   329,   329,   333,    -1,   317,   334,
   337,   320,   329,    -1,    19,    -1,    21,    -1,    23,    -1,
    -1,    -1,    27,    28,    -1,    30,    31,    -1,    33,    -1,
    -1,    36,    -1,    38,    -1,    -1,    -1,    42,    43,    44,
    45,    46,     3,    -1,    49,    50,    51,    52,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    60,    -1,    -1,    19,    64,
    21,    22,    23,    -1,    -1,    26,    27,    28,    -1,    30,
    31,    -1,    33,    -1,    -1,    36,     3,    38,    -1,    -1,
    -1,    42,    43,    44,    45,    46,    -1,    -1,    49,    50,
    51,    52,    19,    -1,    21,    -1,    23,    -1,    -1,    60,
    27,    28,    -1,    30,    31,    -1,    33,    -1,    -1,    36,
     3,    38,    -1,    -1,    -1,    42,    43,    44,    45,    46,
    -1,    -1,    49,    50,    51,    52,    19,    -1,    21,    -1,
    23,    -1,    -1,    60,    27,    -1,    -1,    30,    31,    -1,
    33,    -1,    -1,    36,     3,    38,    -1,    -1,    -1,    42,
    43,    44,    45,    12,    -1,    -1,    -1,    50,    51,    52,
    19,    -1,    21,    -1,    23,    -1,    -1,    60,    27,    -1,
    -1,    30,    31,    -1,    33,    -1,    -1,    36,     3,    38,
    -1,    -1,    -1,    42,    -1,    44,    45,    -1,    -1,    -1,
    -1,    50,    51,    52,    19,    -1,    21,    -1,    23,    -1,
    -1,    60,    27,    -1,    -1,    30,    31,    -1,    33,    -1,
    -1,    36,    -1,    38,    -1,    11,    -1,    42,    -1,    44,
    45,    -1,    -1,    -1,    20,    50,    51,    52,    24,    11,
    -1,    -1,    28,    29,    -1,    60,    -1,    -1,    20,    -1,
    -1,    37,    24,    -1,    40,     3,    28,    29,    -1,    -1,
    46,    -1,    48,    49,    -1,    37,    -1,    -1,    40,    55,
    56,    57,    -1,    21,    46,    23,    48,    49,    64,    27,
    -1,    -1,    30,    31,    -1,    33,    -1,    16,    17,    18,
    38,    -1,    64,    -1,    42,    24,    44,    45,     3,    28,
    29,    -1,    50,    51,    52,    -1,    35,    -1,    37,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    21,    46,    23,    48,
    49,    -1,    -1,    28,    53,    54,    -1,    -1,    33,    -1,
    -1,    -1,    61,    38,    -1,    64,    -1,    42,    -1,    44,
    16,    17,    18,    -1,    -1,    50,    51,    -1,    24,    -1,
    -1,    -1,    28,    29,    -1,    -1,    32,    -1,    -1,    35,
    -1,    37,    -1,    16,    17,    18,    -1,    -1,    -1,    -1,
    46,    24,    48,    49,    -1,    28,    29,    53,    54,    -1,
    -1,    -1,    35,    -1,    37,    61,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    46,    -1,    48,    49,    -1,    -1,    -1,
    53,    54,    -1,    -1,    -1,    -1,    -1,    -1,    61
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "./bison.skel"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */


#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#define YYLEX		yylex(&yylval, &yylloc)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 184 "./bison.skel"
int
yyparse()
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 1:
#line 208 "idlparser.y"
{the_result=yyvsp[0].definition_list;;
    break;}
case 9:
#line 220 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=MODULEtag;
		yyval.definition->name=yyvsp[-3].name;
		yyval.definition->u.module.definitions=yyvsp[-1].definition_list;
	;
    break;}
case 10:
#line 226 "idlparser.y"
{       yyval.definition_list=iluparser_new_list();deflist_insert(yyval.definition_list,yyvsp[0].definition);;
    break;}
case 11:
#line 228 "idlparser.y"
{	deflist_insert(yyvsp[-1].definition_list,yyvsp[0].definition);
		yyval.definition_list=yyvsp[-1].definition_list;
	;
    break;}
case 14:
#line 237 "idlparser.y"
{	yyvsp[-3].definition->u.interface.definitions=yyvsp[-1].definition_list;
		yyval.definition=yyvsp[-3].definition;
	;
    break;}
case 15:
#line 242 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=INTERFACEFWDtag;
		yyval.definition->name=yyvsp[0].name;
		yyval.definition->u.interface.abstract = yyvsp[-2].flag;
	;
    break;}
case 16:
#line 247 "idlparser.y"
{ yyval.flag = FALSE; ;
    break;}
case 17:
#line 248 "idlparser.y"
{ yyval.flag = TRUE; ;
    break;}
case 18:
#line 251 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=INTERFACEtag;
		yyval.definition->name=yyvsp[0].name;
		yyval.definition->u.interface.abstract = yyvsp[-2].flag;
		yyval.definition->u.interface.bases=NULL;
		yyval.definition->u.interface.definitions=NULL;
		yyval.definition->u.interface.resolution_state=0;
	;
    break;}
case 19:
#line 259 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=INTERFACEtag;
		yyval.definition->name=yyvsp[-2].name;
		yyval.definition->u.interface.abstract = yyvsp[-4].flag;
		yyval.definition->u.interface.bases=yyvsp[0].name_list;
		yyval.definition->u.interface.definitions=NULL;
		yyval.definition->u.interface.resolution_state=0;
	;
    break;}
case 20:
#line 268 "idlparser.y"
{yyval.definition_list=iluparser_new_list();;
    break;}
case 27:
#line 278 "idlparser.y"
{ 
		yyval.definition_list=iluparser_new_list();
		deflist_insert(yyval.definition_list,yyvsp[0].definition);
	;
    break;}
case 28:
#line 283 "idlparser.y"
{	yyval.definition_list=yyvsp[-1].definition_list;deflist_insert(yyval.definition_list,yyvsp[0].definition);
	;
    break;}
case 30:
#line 287 "idlparser.y"
{yyval.name=yyvsp[0].name;yyvsp[0].name->scope=new_name();;
    break;}
case 31:
#line 288 "idlparser.y"
{yyval.name=yyvsp[0].name;yyval.name->scope=yyvsp[-2].name;;
    break;}
case 32:
#line 292 "idlparser.y"
{	yyval.name_list=iluparser_new_list();
		list_insert(yyval.name_list,yyvsp[0].name);
	;
    break;}
case 33:
#line 296 "idlparser.y"
{	yyval.name_list=yyvsp[-2].name_list;list_insert(yyval.name_list,yyvsp[0].name);
	;
    break;}
case 38:
#line 306 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = VALUEFWDtag;
		yyval.definition->name = yyvsp[0].name;
		yyval.definition->u.value.abstract = FALSE;
		yyval.definition->u.value.truncatable = FALSE;
	;
    break;}
case 39:
#line 313 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = VALUEFWDtag;
		yyval.definition->name = yyvsp[0].name;
		yyval.definition->u.value.abstract = TRUE;
		yyval.definition->u.value.truncatable = FALSE;
	;
    break;}
case 40:
#line 322 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = VALUEBOXtag;
		yyval.definition->name = yyvsp[-1].name;
		yyval.definition->u.type = yyvsp[0].type;
		/* value boxes have their point-of-definition
		   at the end - arrange this by changing the serial */
		yyval.definition->name->serial = ++next_serial;
		
	;
    break;}
case 41:
#line 334 "idlparser.y"
{	yyval.definition = yyvsp[-3].definition;
		yyval.definition->name = yyvsp[-4].name;
		yyval.definition->u.value.abstract = TRUE;
		yyval.definition->u.value.custom = FALSE;
		yyval.definition->u.value.definitions = yyvsp[-1].definition_list;
	;
    break;}
case 42:
#line 342 "idlparser.y"
{	yyval.definition = yyvsp[-3].definition;
		yyval.definition->u.value.definitions = yyvsp[-1].definition_list;
	;
    break;}
case 43:
#line 347 "idlparser.y"
{	yyval.definition = yyvsp[0].definition;
		yyval.definition->name = yyvsp[-1].name;
		yyval.definition->u.value.abstract = yyval.definition->u.value.custom = FALSE;
	;
    break;}
case 44:
#line 352 "idlparser.y"
{	yyval.definition = yyvsp[0].definition;
		yyval.definition->name = yyvsp[-1].name;
		yyval.definition->u.value.abstract = FALSE;
		yyval.definition->u.value.custom = TRUE;
	;
    break;}
case 45:
#line 359 "idlparser.y"
{	yyval.definition = yyvsp[0].definition;
		yyval.definition->u.value.supports = 0;
	;
    break;}
case 46:
#line 363 "idlparser.y"
{	yyval.definition = yyvsp[-2].definition;
		yyval.definition->u.value.supports = yyvsp[0].name_list;
	;
    break;}
case 47:
#line 368 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = VALUEtag;
		yyval.definition->u.value.truncatable = FALSE;
		yyval.definition->u.value.bases = 0;
	;
    break;}
case 48:
#line 374 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = VALUEtag;
		yyval.definition->u.value.truncatable = yyvsp[-1].flag;
		yyval.definition->u.value.bases = yyvsp[0].name_list;
	;
    break;}
case 49:
#line 382 "idlparser.y"
{	yyval.flag = FALSE;;
    break;}
case 50:
#line 384 "idlparser.y"
{	yyval.flag = TRUE;;
    break;}
case 51:
#line 387 "idlparser.y"
{	yyval.definition_list = iluparser_new_list ();;
    break;}
case 52:
#line 389 "idlparser.y"
{	deflist_insert(yyvsp[-1].definition_list,yyvsp[0].definition);
		yyval.definition_list = yyvsp[-1].definition_list;
	;
    break;}
case 56:
#line 398 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = STATELISTtag;
		yyval.definition->u.statelist.private = yyvsp[-3].flag;
		yyval.definition->u.statelist.type = yyvsp[-2].type;
		yyval.definition->u.statelist.names = yyvsp[-1].name_list;
	;
    break;}
case 57:
#line 405 "idlparser.y"
{ yyval.flag = TRUE; ;
    break;}
case 58:
#line 406 "idlparser.y"
{ yyval.flag = FALSE;;
    break;}
case 59:
#line 409 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = FACTORYtag;
		yyval.definition->name = yyvsp[-4].name;
		yyval.definition->u.operation.returntype = 0;
		yyval.definition->u.operation.parameters = yyvsp[-2].definition_list;
		yyval.definition->u.operation.raises = 0;
		yyval.definition->u.operation.context = 0;
	;
    break;}
case 60:
#line 419 "idlparser.y"
{	yyval.definition_list = iluparser_new_list();;
    break;}
case 62:
#line 423 "idlparser.y"
{	yyval.definition_list = iluparser_new_list();
		list_insert(yyval.definition_list, yyvsp[0].definition);
	;
    break;}
case 63:
#line 427 "idlparser.y"
{	list_insert(yyvsp[-2].definition_list, yyvsp[0].definition);
		yyval.definition_list = yyvsp[-2].definition_list;
	;
    break;}
case 64:
#line 432 "idlparser.y"
{	yyval.definition = new_definition();
		yyval.definition->tag = PARAMETERtag;
		yyval.definition->u.parameter.direction = In;
		yyval.definition->u.parameter.type = yyvsp[-1].type;
		yyval.definition->name = yyvsp[0].name;
	;
    break;}
case 65:
#line 441 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=CONSTtag;
		yyval.definition->name=yyvsp[-2].name;
		yyval.definition->u.constant.type=yyvsp[-3].type;
		yyval.definition->u.constant.val=yyvsp[0].value;
		yyval.definition->u.constant.computed=FALSE;
	;
    break;}
case 75:
#line 458 "idlparser.y"
{
		yyval.type=new_referenced(yyvsp[0].name);
	;
    break;}
case 78:
#line 465 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'|',yyvsp[0].value);;
    break;}
case 80:
#line 469 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'^',yyvsp[0].value);;
    break;}
case 82:
#line 473 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'&',yyvsp[0].value);;
    break;}
case 84:
#line 476 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'L',yyvsp[0].value);;
    break;}
case 85:
#line 478 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'R',yyvsp[0].value);;
    break;}
case 87:
#line 481 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'+',yyvsp[0].value);;
    break;}
case 88:
#line 483 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'-',yyvsp[0].value);;
    break;}
case 90:
#line 486 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'*',yyvsp[0].value);;
    break;}
case 91:
#line 488 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'/',yyvsp[0].value);;
    break;}
case 92:
#line 490 "idlparser.y"
{	yyval.value=new_binary(yyvsp[-2].value,'%',yyvsp[0].value);;
    break;}
case 93:
#line 491 "idlparser.y"
{yyval.value=new_unary(yyvsp[-1].opname,yyvsp[0].value);;
    break;}
case 95:
#line 493 "idlparser.y"
{yyval.opname='+';;
    break;}
case 96:
#line 494 "idlparser.y"
{yyval.opname='-';;
    break;}
case 97:
#line 495 "idlparser.y"
{yyval.opname='~';;
    break;}
case 98:
#line 497 "idlparser.y"
{	yyval.value=new_value();yyval.value->tag=idl_named;
		yyval.value->u.named=yyvsp[0].name;
	;
    break;}
case 100:
#line 501 "idlparser.y"
{yyval.value=yyvsp[-1].value;;
    break;}
case 111:
#line 514 "idlparser.y"
{
	  char *s=iluparser_Malloc(strlen(yyvsp[-1].value->u.string)
				   +strlen(yyvsp[0].value->u.string)+1);
	  strcpy(s,yyvsp[-1].value->u.string);strcat(s,yyvsp[0].value->u.string);
	  yyval.value = yyvsp[-1].value;
	  yyval.value->u.string = s;
	  if (yyvsp[-1].value->tag != yyvsp[0].value->tag){
	    fprintf (stderr, "Concatenating narrow and wide string\n");
	    YYERROR;
	  }
	;
    break;}
case 112:
#line 526 "idlparser.y"
{yyval.definition=yyvsp[0].definition;;
    break;}
case 116:
#line 531 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=TYPEtag;
		yyval.definition->name=yyvsp[0].name;
	  	yyval.definition->u.type=new_type();yyval.definition->u.type->tag=NATIVEtag;
	;
    break;}
case 117:
#line 537 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=TYPELISTtag;
		yyval.definition->u.typelist.type=yyvsp[-1].type;
		yyval.definition->u.typelist.names=yyvsp[0].name_list;
	;
    break;}
case 119:
#line 544 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=DEFINEDtag;
		yyval.type->u.defined=yyvsp[0].definition;
		yyval.type->name=yyvsp[0].definition->name;
	;
    break;}
case 122:
#line 552 "idlparser.y"
{
		yyval.type=new_referenced(yyvsp[0].name);
	;
    break;}
case 139:
#line 576 "idlparser.y"
{	yyval.name_list=iluparser_new_list();
		list_insert(yyval.name_list,yyvsp[0].name);
	;
    break;}
case 140:
#line 580 "idlparser.y"
{	yyval.name_list=yyvsp[-2].name_list;list_insert(yyval.name_list,yyvsp[0].name);;
    break;}
case 145:
#line 588 "idlparser.y"
{yyval.type=the_float_t;;
    break;}
case 146:
#line 589 "idlparser.y"
{yyval.type=the_double_t;;
    break;}
case 152:
#line 598 "idlparser.y"
{yyval.type=the_long_long_t;;
    break;}
case 153:
#line 599 "idlparser.y"
{yyval.type=the_long_t;;
    break;}
case 154:
#line 600 "idlparser.y"
{yyval.type=the_short_t;;
    break;}
case 158:
#line 605 "idlparser.y"
{yyval.type=the_unsigned_long_long_t;;
    break;}
case 159:
#line 606 "idlparser.y"
{yyval.type=the_unsigned_long_t;;
    break;}
case 160:
#line 607 "idlparser.y"
{yyval.type=the_unsigned_short_t;;
    break;}
case 161:
#line 609 "idlparser.y"
{yyval.type=the_char_t;;
    break;}
case 162:
#line 610 "idlparser.y"
{yyval.type=the_wchar_t;;
    break;}
case 163:
#line 611 "idlparser.y"
{yyval.type=the_boolean_t;;
    break;}
case 164:
#line 612 "idlparser.y"
{yyval.type=the_octet_t;;
    break;}
case 165:
#line 613 "idlparser.y"
{yyval.type=the_any_t;;
    break;}
case 166:
#line 614 "idlparser.y"
{yyval.type=the_object_t;;
    break;}
case 167:
#line 615 "idlparser.y"
{yyval.type=the_valuebase_t;;
    break;}
case 168:
#line 618 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=TYPEtag;
		yyval.definition->name=yyvsp[-3].name;
		yyval.definition->u.type=new_type();
		yyval.definition->u.type->tag=STRUCTtag;
		yyval.definition->u.type->has_scope=TRUE;
		yyval.definition->u.type->u.structure=yyvsp[-1].definition_list;
		yyval.definition->u.type->name=yyvsp[-3].name;
	;
    break;}
case 169:
#line 627 "idlparser.y"
{	yyval.definition_list=iluparser_new_list();deflist_insert(yyval.definition_list,yyvsp[0].definition);;
    break;}
case 170:
#line 629 "idlparser.y"
{	deflist_insert(yyvsp[-1].definition_list,yyvsp[0].definition);yyval.definition_list=yyvsp[-1].definition_list;;
    break;}
case 171:
#line 631 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=MEMBERLISTtag;
		yyval.definition->u.typelist.type=yyvsp[-2].type;
		yyval.definition->u.typelist.names=yyvsp[-1].name_list;
	;
    break;}
case 172:
#line 637 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=TYPEtag;
		yyval.definition->name=yyvsp[-7].name;
		yyval.definition->u.type=new_type();yyval.definition->u.type->tag=UNIONtag;
		yyval.definition->u.type->has_scope=TRUE;
		yyval.definition->u.type->u._union.head=yyvsp[-4].type;
		/* make identifiers in switch_type_spec visible */
		type_insert(yyvsp[-1].definition_list,yyvsp[-4].type);
		yyval.definition->u.type->u._union.body=yyvsp[-1].definition_list;
		yyval.definition->u.type->u._union._default=0;
	;
    break;}
case 178:
#line 654 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=DEFINEDtag;yyval.type->u.defined=yyvsp[0].definition;;
    break;}
case 179:
#line 656 "idlparser.y"
{	yyval.type=new_referenced(yyvsp[0].name);
	;
    break;}
case 180:
#line 660 "idlparser.y"
{	yyval.definition_list=iluparser_new_list();deflist_insert(yyval.definition_list,yyvsp[0].definition);;
    break;}
case 181:
#line 662 "idlparser.y"
{	yyval.definition_list=yyvsp[-1].definition_list;deflist_insert(yyval.definition_list,yyvsp[0].definition);;
    break;}
case 182:
#line 665 "idlparser.y"
{	yyval.definition=yyvsp[-1].definition;yyval.definition->u._case.labels=yyvsp[-2].caselabel_list;;
    break;}
case 183:
#line 668 "idlparser.y"
{	yyval.caselabel_list=iluparser_new_list();list_insert(yyval.caselabel_list,yyvsp[0].caselabel);;
    break;}
case 184:
#line 670 "idlparser.y"
{	yyval.caselabel_list=yyvsp[-1].caselabel_list;list_insert(yyval.caselabel_list,yyvsp[0].caselabel);;
    break;}
case 185:
#line 673 "idlparser.y"
{	yyval.caselabel=new_case();yyval.caselabel->value=yyvsp[-1].value;;
    break;}
case 186:
#line 675 "idlparser.y"
{	yyval.caselabel=new_case();;
    break;}
case 187:
#line 678 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=CASEtag;
		yyval.definition->name=yyvsp[0].name;
		yyval.definition->u._case.type=yyvsp[-1].type;
	;
    break;}
case 188:
#line 684 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=TYPEtag;
		yyval.definition->name=yyvsp[-3].name;
		yyval.definition->u.type=new_type();
		yyval.definition->u.type->tag=ENUMtag;
		yyval.definition->u.type->u.enumerated=yyvsp[-1].name_list;
	;
    break;}
case 189:
#line 691 "idlparser.y"
{	yyval.name_list=iluparser_new_list();list_insert(yyval.name_list,yyvsp[0].definition);;
    break;}
case 190:
#line 693 "idlparser.y"
{	yyval.name_list=yyvsp[-2].name_list;list_insert(yyval.name_list,yyvsp[0].definition);;
    break;}
case 191:
#line 695 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=ENUMVALtag;
		yyval.definition->name=yyvsp[0].name;
		yyval.definition->u.enumval=new_value();
		yyval.definition->u.enumval->tag=idl_enum;
		yyval.definition->u.enumval->u.enumerated.type=0;
		yyval.definition->u.enumval->u.enumerated.name=yyvsp[0].name;
	;
    break;}
case 192:
#line 704 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=SEQUENCEtag;
		yyval.type->u.sequence.size=yyvsp[-1].value;
		yyval.type->u.sequence.type=yyvsp[-3].type;
	;
    break;}
case 193:
#line 709 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=SEQUENCEtag;
		yyval.type->u.sequence.size=NULL;
		yyval.type->u.sequence.type=yyvsp[-1].type;
	;
    break;}
case 194:
#line 715 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=STRINGtag;yyval.type->u.stringsize=yyvsp[-1].value;;
    break;}
case 195:
#line 717 "idlparser.y"
{	yyval.type=the_string_t;;
    break;}
case 196:
#line 720 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=WSTRINGtag;yyval.type->u.stringsize=yyvsp[-1].value;;
    break;}
case 197:
#line 722 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=WSTRINGtag;yyval.type->u.stringsize=0;;
    break;}
case 198:
#line 725 "idlparser.y"
{	yyvsp[-1].name->array=iluparser_new_list();list_insert(yyval.name->array,yyvsp[0].value);
		yyval.name=yyvsp[-1].name;
	;
    break;}
case 199:
#line 729 "idlparser.y"
{	yyval.name=yyvsp[-1].name;list_insert(yyval.name->array,yyvsp[0].value);;
    break;}
case 200:
#line 731 "idlparser.y"
{yyval.value=yyvsp[-1].value;;
    break;}
case 201:
#line 734 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=ATTRIBUTEtag;
		yyval.definition->name=yyvsp[0].name;
		yyval.definition->u.attribute.readonly=yyvsp[-3].flag;
		yyval.definition->u.attribute.type=yyvsp[-1].type;
		yyval.definition->u.attribute.names=0;
	;
    break;}
case 202:
#line 741 "idlparser.y"
{	if(yyvsp[-2].definition->tag==ATTRIBUTEtag){
			yyvsp[-2].definition->tag=ATTRLISTtag;
			yyvsp[-2].definition->u.attribute.names=iluparser_new_list();
			list_insert(yyvsp[-2].definition->u.attribute.names,yyvsp[-2].definition->name);
			yyvsp[-2].definition->name=0;
		}
		yyval.definition=yyvsp[-2].definition;list_insert(yyvsp[-2].definition->u.attribute.names,yyvsp[0].name);
	;
    break;}
case 203:
#line 750 "idlparser.y"
{yyval.flag=FALSE;;
    break;}
case 204:
#line 751 "idlparser.y"
{yyval.flag=TRUE;;
    break;}
case 205:
#line 754 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=EXCEPTIONtag;
		yyval.definition->name=yyvsp[-3].name;
		yyval.definition->u.exception.members=yyvsp[-1].definition_list;
	;
    break;}
case 206:
#line 758 "idlparser.y"
{yyval.definition_list=0;;
    break;}
case 208:
#line 763 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=OPERATIONtag;
		yyval.definition->u.operation.oneway=yyvsp[-5].flag;
		yyval.definition->u.operation.returntype=yyvsp[-4].type;
		yyval.definition->name=yyvsp[-3].name;
		yyval.definition->u.operation.parameters=yyvsp[-2].definition_list;
		yyval.definition->u.operation.raises=yyvsp[-1].name_list;
		yyval.definition->u.operation.context=yyvsp[0].string_list;
	;
    break;}
case 209:
#line 772 "idlparser.y"
{yyval.flag=FALSE;;
    break;}
case 210:
#line 773 "idlparser.y"
{yyval.flag=TRUE;;
    break;}
case 212:
#line 776 "idlparser.y"
{yyval.type=the_void_t;;
    break;}
case 213:
#line 778 "idlparser.y"
{ yyval.definition_list=yyvsp[-1].definition_list;;
    break;}
case 214:
#line 780 "idlparser.y"
{	yyval.definition_list=iluparser_new_list();;
    break;}
case 215:
#line 783 "idlparser.y"
{ 	yyval.definition_list=iluparser_new_list();list_insert(yyval.definition_list,yyvsp[0].definition);;
    break;}
case 216:
#line 785 "idlparser.y"
{ list_insert(yyvsp[-2].definition_list,yyvsp[0].definition);yyval.definition_list=yyvsp[-2].definition_list;;
    break;}
case 217:
#line 788 "idlparser.y"
{	yyval.definition=new_definition();yyval.definition->tag=PARAMETERtag;
		yyval.definition->u.parameter.direction=yyvsp[-2].inout;
		yyval.definition->u.parameter.type=yyvsp[-1].type;
		yyval.definition->name=yyvsp[0].name;
	;
    break;}
case 218:
#line 794 "idlparser.y"
{yyval.inout=In;;
    break;}
case 219:
#line 795 "idlparser.y"
{yyval.inout=Out;;
    break;}
case 220:
#line 796 "idlparser.y"
{yyval.inout=InOut;;
    break;}
case 221:
#line 798 "idlparser.y"
{yyval.name_list=0;;
    break;}
case 222:
#line 799 "idlparser.y"
{yyval.name_list=yyvsp[-1].name_list;;
    break;}
case 223:
#line 801 "idlparser.y"
{yyval.string_list=0;;
    break;}
case 224:
#line 802 "idlparser.y"
{yyval.string_list=yyvsp[-1].string_list;;
    break;}
case 225:
#line 805 "idlparser.y"
{	yyval.string_list=iluparser_new_list();list_insert(yyval.string_list,yyvsp[0].value);;
    break;}
case 226:
#line 807 "idlparser.y"
{	yyval.string_list=yyvsp[-2].string_list;list_insert(yyval.string_list,yyvsp[0].value);;
    break;}
case 231:
#line 814 "idlparser.y"
{
		yyval.type=new_referenced(yyvsp[0].name);
	;
    break;}
case 232:
#line 819 "idlparser.y"
{	yyval.type=new_type();yyval.type->tag=FIXEDtag;
		yyval.type->u.fixed.digits=yyvsp[-3].value;
		yyval.type->u.fixed.exponent=yyvsp[-1].value;
	;
    break;}
case 233:
#line 824 "idlparser.y"
{yyval.type=the_fixed_t;;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 465 "./bison.skel"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyerror(error_message[yystate]);
#else
      yyerror("parse error");
#endif /* YYERROR_VERBOSE */
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 830 "idlparser.y"


/* Constructors */
IDLDefinition new_definition()
{
  IDLDefinition result;
  result=(IDLDefinition)iluparser_Malloc(sizeof(struct idl_definition));
  result->tag=NILtag;
  result->name=0;
  result->isl=0;
  result->env=0;
  result->prefix=0;
  result->id=0;
  result->version=0;
  return result;
}

IDLType new_type()
{
  IDLType result;
  result=(IDLType)iluparser_Malloc(sizeof(struct idl_type));
  result->tag=NULLTYPEtag;
  result->has_scope=FALSE;
#ifndef STANDALONE
  result->isl=NULL;
#endif
  result->name=NULL;
  result->anon_def=NULL;
  return result;
}

IDLName new_name()
{
  IDLName result=(IDLName)iluparser_Malloc(sizeof(struct idl_name));
  next_serial++;
  result->serial=next_serial;
  result->file=NULL;
  result->line=0;
  result->env=NULL;
  result->scope=NULL;
  result->name=NULL;
#ifndef STANDALONE
  result->lifted=NULL;
#endif
  result->value=NULL;
  result->array=NULL;
  result->no_ordering=0;
  return result;
}

IDLValue new_value()
{
  IDLValue result;
  result=(IDLValue)iluparser_Malloc(sizeof(struct idl_value));
  result->tag=idl_void;
  result->value=NULL;
  result->isl=NULL;
  return result;
}

IDLCase new_case()
{
  IDLCase result;
  result=(IDLCase)iluparser_Malloc(sizeof(struct idl_case));
  result->value=0;
#ifndef STANDALONE
  result->isl=0;
#endif
  return result;
}

/*********************** complex constructors ***************************/

IDLType new_referenced(IDLName n)
{		
  IDLType result=new_type();
  result->tag=REFERENCEDtag;
  result->u.referenced.name=n;
  result->u.referenced.val=0;
  return result;
}

IDLValue new_unary(char opname,IDLValue val)
{
  IDLValue result=new_value();
  result->tag=idl_unary;
  result->u.unary.operator=opname;
  result->u.unary.arg=val;
  return result;
}

IDLValue new_binary(IDLValue val1,char opname,IDLValue val2)
{
  IDLValue result=new_value();
  result->tag=idl_binary;
  result->u.binary.operator=opname;
  result->u.binary.arg1=val1;
  result->u.binary.arg2=val2;
  return result;
}

static boolean
is_anonymous(IDLType t)
{
  switch(t->tag){
  case FIXEDtag:
    /* this is not supported, yet */
  case WSTRINGtag:
    /* if there was an ilu.WString type, this would not be anonymous */
  case ARRAYtag:
  case SEQUENCEtag:
    return t->name==NULL;
  case STRINGtag:
    /* can use ilu.CString */
    if(t->u.stringsize)return t->name==NULL;
    return t->name==NULL;
  default:
    break;
  }
  return FALSE;
}

static void
declare_type(refany name,refany rock)
{
  refany *r=rock;
  IDLType t,t1;
  IDLDefinition d=new_definition();
  d->tag=TYPEtag;
  d->name=name;
  t=r[0];
  if(d->name->array){
    t1=new_type();
    t1->tag=ARRAYtag;
    t1->name=name;
    t1->u.array.type=t;
    t1->u.array.dimensions=d->name->array;
    d->name->array=0;
    t=t1;
  }else{
    /* this is a possible alias definition */
    if(is_anonymous(t))
      t->name=name;
    else{
      t1=new_type();
      t1->tag=ALIAStag;
      t1->name=name;
      t1->u.alias=t;
      t=t1;
    }
  }
  d->u.type=t;
  list_insert(r[1],d);
}
	
static void
declare_member(refany name,refany rock)
{
  refany *r=rock;
  IDLDefinition d=new_definition();
  d->tag=MEMBERtag;
  d->name=name;
  d->u.member=r[0];
  list_insert(r[1],d);
}

static void
declare_state(refany name,refany rock)
{
  refany *r = rock;
  IDLDefinition d = new_definition();
  IDLDefinition orig = r[0];
  d->tag = STATEtag;
  d->name = name;
  d->u.state.type = orig->u.statelist.type;
  d->u.state.private = orig->u.statelist.private;
  list_insert(r[1],d);
}

static void
declare_attribute(refany name,refany rock)
{
  refany *r=rock;
  IDLDefinition a=r[0];
  IDLDefinition d=new_definition();
  d->tag=ATTRIBUTEtag;
  d->name=name;
  d->u.attribute.type=a->u.attribute.type;
  d->u.attribute.readonly=a->u.attribute.readonly;
  d->u.attribute.names=0;
  list_insert(r[1],d);
}

void
type_insert(list l,IDLType t)
{
  if(t->tag!=DEFINEDtag)return;
  /* typedef struct foo{long bar;} foobar,baz; */
  deflist_insert(l,t->u.defined);
}

static void
declare_enum(refany e,refany rock)
{
  refany *r=rock;
  IDLDefinition d=e;
  d->u.enumval->u.enumerated.type=r[0];
  list_insert(r[1],e);
}

void deflist_insert(list l,IDLDefinition d)
{
  refany rock[2];
  switch(d->tag){
  case TYPELISTtag:
    type_insert(l,d->u.typelist.type);
    rock[0]=d->u.typelist.type;
    rock[1]=l;
    list_enumerate(d->u.typelist.names,declare_type,rock);
    break;
  case MEMBERLISTtag:
    type_insert(l,d->u.typelist.type);
    rock[0]=d->u.typelist.type;
    rock[1]=l;
    list_enumerate(d->u.typelist.names,declare_member,rock);
    break;
  case STATELISTtag:
    type_insert(l,d->u.statelist.type);
    rock[0]=d;
    rock[1]=l;
    list_enumerate(d->u.statelist.names,declare_state,rock);
    break;
  case ATTRLISTtag:
    type_insert(l,d->u.attribute.type);
    rock[0]=d;
    rock[1]=l;
    list_enumerate(d->u.attribute.names,declare_attribute,rock);
    break;
  case CASEtag:
    type_insert(l,d->u._case.type);
    list_insert(l,d);
    break;
  case TYPEtag:
    if(d->u.type->tag==ENUMtag){
      /* insert enum values as definitions */
      rock[0]=d->u.type;
      rock[1]=l;
      list_enumerate(d->u.type->u.enumerated,declare_enum,rock);
    }
  default:
    list_insert(l,d);
  }
}

#ifndef STANDALONE
Type new_Type(void);
TypeDescription new_TypeDescription(void);
Name new_Name(void);

static void
primitive_setuid(Type T)
{
  if(!T->uid){
    char buf[100];
    FigureTypeUID(T);
    /* FIXME: work around FigureTypeUid setting the mark */
    sprintf(buf,"(%s)",type_name(T));
    name_set_lang_name(T->name,"parser:full",buf);
  }
}

static boolean
find_ilu_type(refany object,refany string)
{
  Type t=object;
  return strcmp(name_base_name(t->name),string)==0;
}

int init_types()
{
	IDLType v;
	Type t;
	TypeDescription d;
#define ADD_PRIMITIVE_TYPE(n)\
	v=the_##n##_t= new_type();\
	v->tag=BASICtag;\
	v->u.basic=idl_##n;

  ADD_PRIMITIVE_TYPES;

  /* need to get ilu before making a call to FigureTypeUID */
  the_ilu_module = GetInterface("ilu",0);
  if (!the_ilu_module)
    return 0;

#undef ADD_PRIMITIVE_TYPE
#define ADD_PRIMITIVE_TYPE(n,str,tk)\
        v=the_##n##_t;\
	v->isl=t=new_Type();\
	t->description=d=new_TypeDescription();\
	d->type=tk;\
	t->builtIn=TRUE;\
	name_set_base_name(t->name,str);\
	primitive_setuid(t);

  ADD_PRIMITIVE_TYPE (short, "shortinteger", shortinteger_Type);
  ADD_PRIMITIVE_TYPE (long, "integer", integer_Type);
  ADD_PRIMITIVE_TYPE (long_long, "longinteger", longinteger_Type);
  ADD_PRIMITIVE_TYPE (unsigned_short, "shortcardinal", shortcardinal_Type);
  ADD_PRIMITIVE_TYPE (unsigned_long, "cardinal", cardinal_Type);
  ADD_PRIMITIVE_TYPE (unsigned_long_long, "longcardinal", longcardinal_Type);
  ADD_PRIMITIVE_TYPE (double, "real", real_Type);
  ADD_PRIMITIVE_TYPE (float, "shortreal", shortreal_Type);
  ADD_PRIMITIVE_TYPE (octet, "byte", byte_Type);
  ADD_PRIMITIVE_TYPE (boolean, "boolean", boolean_Type);
  ADD_PRIMITIVE_TYPE (char, "shortcharacter", shortcharacter_Type);
  ADD_PRIMITIVE_TYPE (wchar, "character", character_Type);
  ADD_PRIMITIVE_TYPE (any, "pickle", pickle_Type);

  /* not supported by IDL
  ADD_PRIMITIVE_TYPE ( "longreal", longreal_Type);
  */

  /* look for ilu.CORBA-Object */
  the_CORBA_Object = list_find(the_ilu_module->classes,
			       find_ilu_type,"CORBA-Object");
  the_ilu_CString = list_find(the_ilu_module->types,find_ilu_type,"CString");
  /* import this type */
  t=new_Type();
  t->name=new_Name();
  name_set_base_name(t->name,name_base_name(the_CORBA_Object->name));
  name_set_lang_name(t->name,"import","CORBA-Object");
  t->supertype=the_CORBA_Object;
  t->importInterfaceName = "ilu";
  t->interface=the_CORBA_Object->interface;
  t->uid=the_CORBA_Object->uid;
  t->explicit_uid = TRUE;
  t->brand = NULL;
  the_CORBA_Object=t;
  the_object_t = new_type();
  the_object_t->tag=BASICtag;
  the_object_t->u.basic=idl_object;
  the_object_t->isl=the_CORBA_Object;

  /* Not yet */
  the_valuebase_t = NULL;

  the_string_t=new_type();
  the_string_t->tag=STRINGtag;
  the_string_t->u.stringsize=0;
  the_string_t->isl=t=new_Type();
  /* make this type an imported ilu.CString */
  t->name=new_Name();
  name_set_base_name(t->name,name_base_name(the_ilu_CString->name));
  name_set_lang_name(t->name,"import","CString");
  t->supertype=the_ilu_CString;
  t->importInterfaceName="ilu";
  t->interface=the_ilu_CString->interface;
  t->uid=the_ilu_CString->uid;
  t->explicit_uid=TRUE;
  t->brand = NULL;

  the_fixed_t=new_type();
  the_fixed_t->tag=FIXEDtag;
  the_fixed_t->u.fixed.digits=0;
  the_fixed_t->u.fixed.exponent=0;

  /* success */
  return 1;
}
#else /* STANDALONE */
int init_types()
{
  IDLType v;
#define ADD_PRIMITIVE_TYPE(n)\
	v=the_##n##_t= new_type();\
	v->tag=BASICtag;\
	v->u.basic=idl_##n;

  ADD_PRIMITIVE_TYPES;

  the_object_t = new_type();
  the_object_t->tag=BASICtag;
  the_object_t->u.basic=idl_object;

  the_valuebase_t = new_type();
  the_valuebase_t->tag=BASICtag;
  the_valuebase_t->u.basic=idl_valuebase;

  the_string_t=new_type();
  the_string_t->tag=STRINGtag;
  the_string_t->u.stringsize=0;

  the_fixed_t=new_type();
  the_fixed_t->tag=FIXEDtag;
  the_fixed_t->u.fixed.digits=0;
  the_fixed_t->u.fixed.exponent=0;

  /* success */
  return 1;
}
#endif

int idlerror(char *s)
{
#ifdef YYERROR_VERBOSE
  extern char *idltext;
  fprintf(stderr,"%s:%ld:parse error before '%s'\n%s\n",
	  idlcurrentfile(),(long)idlcurrentline(),idltext,s);
#else
  fprintf(stderr,"%s:%ld:%s\n",idlcurrentfile(),idlcurrentline(),s);
#endif
  return 0;
}

void
name_warning(IDLName n,char *s)
{
  if(n)
    fprintf(stderr,"%s:%ld: %s: %s\n",n->file,(long)n->line,n->name,s);
  else
    fprintf(stderr,"<no line>: %s\n",s);
}

void
idl_name_error(IDLName n,char *s)
{
  name_warning(n,s);
  exit(1);
}

/********* Print functions **************************************/
static void 
name_print(FILE *f,IDLName n)
{
  if(n->scope){
    name_print(f,n->scope);
    fprintf(f,"::");
  }else if(n->name)
    fprintf(f,"%s",n->name);
  else
    fprintf(f,"::");
}

void definition_print(FILE* f,IDLDefinition d)
{
  char *n="unknown definition";
  if(d->env)
    definition_print(f,d->env);
  if(d->name && d->name->name)
    n=d->name->name;
  fprintf(f,"::%s",n);
}

/* Returns a list of definitions inside this one. */

static list
get_nested_definitions(IDLDefinition d)
{
  switch (d->tag) {
    /* those should not happen */
  case NILtag:case TYPELISTtag:case MEMBERLISTtag:case ATTRLISTtag:
  case STATELISTtag:
    assert(0);
    break;
  case MODULEtag:
    return d->u.module.definitions;
  case INTERFACEtag:
    return d->u.interface.definitions;
  case VALUEtag:
    return d->u.value.definitions;
  case FACTORYtag:
  case OPERATIONtag:
    return d->u.operation.parameters;
  case EXCEPTIONtag:
    return d->u.exception.members;
  case TYPEtag:
    /* Handled separately. */
    break;
    /* No nested names */
  case CONSTtag:case MEMBERtag:case PARAMETERtag:case CASEtag:
  case ATTRIBUTEtag:case INTERFACEFWDtag:case ENUMVALtag:
  case PRAGMA_IDtag:case PRAGMA_VERSIONtag:case PRAGMA_PREFIXtag:
  case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
  case VALUEFWDtag:case VALUEBOXtag:case STATEtag:
    break;
  }
  return 0;
}

/************************* Name lookup ***************************/

IDLDefinition
up_find_definition(IDLDefinition d,enum idldefinition_tag t)
{
  while(d && d->tag!=t)
    d=d->env;
  return d;
}

IDLDefinition
toplevel_module(IDLDefinition d)
{
  if(!d->env)return d;
  return toplevel_module(d->env);
}

static boolean
cmp_name(refany def,refany name)
{
  boolean result;
  IDLDefinition d=def;
  /* pragma prefix does not have a name */
  if(!d->name)return FALSE;
  if(d->name->scope)return FALSE;
  /* catch cases where it doesn't define something */
  switch(d->tag){
  case PRAGMA_PREFIXtag:case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
  case PRAGMA_IDtag:
  case PRAGMA_VERSIONtag:
  case INTERFACEFWDtag:
  case VALUEFWDtag:
    return FALSE;
  default:
    break;
  }
  /* IDL is case-insensitive */
  result=ilu_strcasecmp(d->name->name,name)==0;
  /* check for consistent spelling */
  if(result && strcmp(d->name->name,name)!=0)
    idl_name_error(d->name,aprintf("also spelled as '%s'.",name));
  return result;
}

struct lookup_base_s{
  char *name;
  IDLDefinition result;
  IDLDefinition def;
};

static IDLDefinition lookup_name_in_scope(IDLDefinition d,char* n);

static void
lookup_base(refany name,refany rock)
{
  struct lookup_base_s *r=rock;
  IDLName n=name;
  IDLDefinition found=lookup_name_in_scope(n->value,r->name);
  if(r->result && found && r->result!=found){
    idl_name_error(r->def->name,aprintf("ambiguous resolution for %s",r->name));
    return;
  }
  if(found)
    r->result=found;
}

static IDLDefinition
lookup_name_in_scope (IDLDefinition d,char* n)
{
  list locals = get_nested_definitions (d);
  IDLDefinition result = 0;
  if (locals)
    result = list_find (locals, cmp_name, n);
  switch(d->tag){
  case INTERFACEtag:
    if(!result){
      /* search bases */
      struct lookup_base_s s;
      s.name=n;
      s.result=0;
      s.def=d;
      list_enumerate(d->u.interface.bases,lookup_base,&s);
      result=s.result;
    }
    break;
  case VALUEtag:
    if(!result){
      /* search bases */
      struct lookup_base_s s;
      s.name=n;
      s.result=0;
      s.def=d;
      list_enumerate(d->u.value.bases,lookup_base,&s);
      result=s.result;
    }
    break;
    /* These are handled through get_nested.  */
  case MODULEtag:
  case OPERATIONtag:
  case EXCEPTIONtag:
  case FACTORYtag:
    break;
  case TYPEtag:
    switch(d->u.type->tag){
    case STRUCTtag:
      result=list_find(d->u.type->u.structure,cmp_name,n);
      break;
    case UNIONtag:
      result=list_find(d->u.type->u._union.body,cmp_name,n);
      break;
    default:
      break;
    }
    break;
  /* inside the other definitions, there are no more names */
  default:
    break;
  }
  return result;
}
static IDLDefinition
lookup_name (IDLDefinition d,char* n,list toplevel)
{
  IDLDefinition result = lookup_name_in_scope (d, n);
  if(!result) {
    if(!d->env)
      /* not found, need toplevel lookup */
      return list_find(toplevel,cmp_name,n);
    else 
      return lookup_name(d->env,n,toplevel);
  }
  return result;
}

/************************** module reopening pass ******************/

static void list_insert1(refany i,refany l)
{
  list_insert(l,i);
}

static void find_duplicate_modules(refany def,refany l)
{
  IDLDefinition d=def;
  if(d->tag==MODULEtag){
    IDLDefinition first=list_find(l,cmp_name,d->name->name);
    if(first && first->tag==MODULEtag)
      /* insert definitions of def into first */
      list_enumerate(d->u.module.definitions,list_insert1,
		     first->u.module.definitions);
    else
      list_insert(l,d);
  }
  else
    /* add this definition */
    list_insert(l,d);
}

list reopen_modules(list alt);

static void 
module_reopen_modules(refany def,refany rock)
{
  IDLDefinition d=def;
  if(d->tag!=MODULEtag)return;
  d->u.module.definitions=reopen_modules(d->u.module.definitions);
}

list 
reopen_modules(list alt)
{
  list neu=iluparser_new_list();
  list_enumerate(alt,find_duplicate_modules,neu);
  list_enumerate(neu,module_reopen_modules,0);
  /* delete the old list, leaving the items in the new list */
  list_clear(alt,0);
  return neu;
}

/************************** backlink pass **************************/

void definition_backlink(refany def,refany env);

static void
name_backlink(refany name,refany rock)
{
  IDLName n=name;
  while(n){
    n->env=rock;
    n=n->scope;
  }
}

static void
value_backlink(refany val,refany rock)
{
  IDLValue v=val;
  switch(v->tag){
  case idl_named:
    name_backlink(v->u.named,rock);
    break;
  case idl_unary:
    value_backlink(v->u.unary.arg,rock);
    break;
  case idl_binary:
    value_backlink(v->u.binary.arg1,rock);
    value_backlink(v->u.binary.arg2,rock);
    break;
  default:
    /* nothing to do for other value */
    break;
  }
}

static void
type_backlink(refany type,refany rock)
{
  IDLType t=type;
  switch(t->tag){
  case NULLTYPEtag:
  case BASICtag: 
  case NATIVEtag:
    break;
  case REFERENCEDtag:
    name_backlink(t->u.referenced.name,rock);
    break;
  case ALIAStag:
    type_backlink(t->u.alias,rock);
    break;
  case SEQUENCEtag:
    type_backlink(t->u.sequence.type,rock);
    if(t->u.sequence.size)
      value_backlink(t->u.sequence.size,rock);
    break;
  case STRUCTtag:
    list_enumerate(t->u.structure,definition_backlink,rock);
    break;
  case ENUMtag:
    break;
  case UNIONtag:
    type_backlink(t->u._union.head,rock);
    list_enumerate(t->u._union.body,definition_backlink,rock);
    break;
  case ARRAYtag:
    type_backlink(t->u.array.type,rock);
    list_enumerate(t->u.array.dimensions,value_backlink,rock);
    break;
  case WSTRINGtag:
  case STRINGtag:
    if(t->u.stringsize)
      value_backlink(t->u.stringsize,rock);
    break;
  case FIXEDtag:
    if(t->u.fixed.digits){
      value_backlink(t->u.fixed.digits,rock);
      value_backlink(t->u.fixed.exponent,rock);
    }
    break;
  case DEFINEDtag:
    definition_backlink(t->u.defined,rock);
    break;
  }
}

static void
case_backlink(refany Case,refany rock)
{
  IDLCase c=Case;
  IDLDefinition d=rock;
  c->env=d;
  if(c->value)
    value_backlink(c->value,d->env);
}

void
definition_backlink(refany def,refany env)
{
  IDLDefinition d=def;
  d->env=env;
  if(d->name){
#ifndef STANDALONE
    d->name->lifted=underscore2hyphen(d->name->name);
#endif
  }
  list_enumerate (get_nested_definitions (d), definition_backlink, d);
  switch(d->tag){
    /* those should not happen */
  case NILtag:case TYPELISTtag:case MEMBERLISTtag:case ATTRLISTtag:
  case STATELISTtag:
    break;
    /* those don't have nested items */
  case INTERFACEFWDtag:
  case VALUEFWDtag:
    break;
    /* Those are handled through get_nested_definitions.  */
  case FACTORYtag:
  case EXCEPTIONtag:
  case MODULEtag:
    break;
  case INTERFACEtag:
    /* base names are used in the environment of the interface */
    list_enumerate(d->u.interface.bases,name_backlink,d->env);
    break;
  case VALUEtag:
    list_enumerate (d->u.value.bases, name_backlink, d->env);
    list_enumerate (d->u.value.supports, name_backlink, d->env);
    break;
  case CONSTtag:
    type_backlink(d->u.constant.type,d->env);
    value_backlink(d->u.constant.val,d->env);
    break;
  case ENUMVALtag:
    break;
  case OPERATIONtag:
    type_backlink(d->u.operation.returntype,d);
    list_enumerate(d->u.operation.raises,name_backlink,d);
    if(d->u.operation.context)
      name_warning(d->name,"Context not supported");
    break;
  case ATTRIBUTEtag:
    type_backlink(d->u.attribute.type,d);
    break;
  case VALUEBOXtag:
    type_backlink(d->u.type,d);
    break;
  case PARAMETERtag:
    type_backlink(d->u.parameter.type,d);
    break;
  case TYPEtag:
    if(d->u.type->has_scope)
      type_backlink(d->u.type,d);
    else
      type_backlink(d->u.type,d->env);
    break;
  case MEMBERtag:
    /* structure fields don't define a scope */
    type_backlink(d->u.member,d->env);
    list_enumerate (d->name->array, value_backlink, d);
    break;
  case STATEtag:
    type_backlink (d->u.state.type, d->env);
    list_enumerate (d->name->array, value_backlink, d);
    break;
  case CASEtag:
    type_backlink(d->u._case.type,d->env);
    list_enumerate(d->u._case.labels,case_backlink,d);
    list_enumerate (d->name->array, value_backlink, d);
    break;
  case PRAGMA_IDtag:
  case PRAGMA_VERSIONtag:
    name_backlink(d->name,env);
    break;
  case PRAGMA_PREFIXtag:case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
    break;
  }
}

/************************* resolvenames pass *************************/
void definition_resolvenames(refany def,refany rock);

static boolean
find_fwd(refany def,refany name)
{
  IDLDefinition d=def;
  IDLName n=name;
  return (d->tag == VALUEFWDtag || d->tag==INTERFACEFWDtag)
    && strcmp(n->name,d->name->name)==0;
}

static void
name_resolvenames(refany name,refany rock)
{
  IDLName n=name;
  if(n->scope){
    /* scoped name */
    if(n->scope->name){
      /* relative scope */
      name_resolvenames(n->scope,rock);
      n->value=lookup_name_in_scope(n->scope->value,n->name);
    }else
      /* absolute scope */
      n->value=list_find(rock,cmp_name,n->name);
  }else if(n->env)
    /* unscoped name used inside a scope */
    n->value=lookup_name(n->env,n->name,rock);
  else
    /* unscoped name used on the toplevel */
    n->value=list_find(rock,cmp_name,n->name);
  if(!n->value)
    idl_name_error(n,"undefined");
  if(n->value->name->serial > n->serial && !n->no_ordering){
    /* this the value is an interface definition,
       a forward declaration would be enough.
       If the interface is used as a base interface,
       the caller will check it */
    if(n->value->tag == INTERFACEtag 
       || n->value->tag == VALUEtag){
      IDLDefinition fwd,mod;
      mod=n->value->env;
      /* the interface is better in a module, if it is in something at all */
      if(mod && mod->tag!=MODULEtag)
	idl_name_error(n,"Internal error, please report");
      if(mod)
	fwd=list_find(mod->u.module.definitions,find_fwd,n->value->name);
      else
	fwd=list_find(rock,find_fwd,n->value->name);
      if(!fwd)
	idl_name_error(n,"missing forward declaration");
      if ((n->value->tag == INTERFACEtag && fwd->tag == VALUEFWDtag)
	  || (n->value->tag == VALUEtag && fwd->tag == INTERFACEFWDtag))
	idl_name_error (n, "illegal forward declaration");
      if(fwd->name->serial > n->serial)
	idl_name_error(n,"used before first forward declaration");
    }else
      /* the name is defined too late */
      idl_name_error(n,"used before definition");
  }
}

static void
value_resolvenames(refany val,refany rock)
{
  IDLValue v=val;
  switch(v->tag){
  case idl_named:
    name_resolvenames(v->u.named,rock);
    break;
  case idl_unary:
    value_resolvenames(v->u.unary.arg,rock);
    break;
  case idl_binary:
    value_resolvenames(v->u.binary.arg1,rock);
    value_resolvenames(v->u.binary.arg2,rock);
    break;
  default:
    break;
  }
}

static void
type_resolvenames(refany type,refany rock)
{
  IDLType t=type;
  switch(t->tag){
  case NULLTYPEtag:
  case BASICtag:
  case NATIVEtag:
    break;
  case REFERENCEDtag:
    name_resolvenames(t->u.referenced.name,rock);
    break;
  case ALIAStag:
    type_resolvenames(t->u.alias,rock);
    break;
  case SEQUENCEtag:
    type_resolvenames(t->u.sequence.type,rock);
    if(t->u.sequence.size)
      value_resolvenames(t->u.sequence.size,rock);
    break;
  case STRUCTtag:
    list_enumerate(t->u.structure,definition_resolvenames,rock);
    break;
  case ENUMtag:
    break;
  case WSTRINGtag:
  case STRINGtag:
    if(t->u.stringsize)
      value_resolvenames(t->u.stringsize,rock);
    break;
  case FIXEDtag:
    if(t->u.fixed.digits){
      value_resolvenames(t->u.fixed.digits,rock);
      value_resolvenames(t->u.fixed.exponent,rock);
    }
    break;
  case UNIONtag:
    type_resolvenames(t->u._union.head,rock);
    list_enumerate(t->u._union.body,definition_resolvenames,rock);
    break;
  case ARRAYtag:
    type_resolvenames(t->u.array.type,rock);
    list_enumerate(t->u.array.dimensions,value_resolvenames,rock);
    break;
  case DEFINEDtag:
    definition_resolvenames(t->u.defined,rock);
    break;
  }
}

static void
case_resolvenames(refany Case,refany rock)
{
  IDLCase c=Case;
  if(c->value)
    value_resolvenames(c->value,rock);
}

static void
interface_resolvenames(refany name,refany rock)
{
  IDLName n=name;
  IDLDefinition d;
  name_resolvenames(n,rock);
  d=n->value;
  if(d->tag!=INTERFACEtag)
    idl_name_error(n,"not an interface");
  definition_resolvenames(d,rock);
}
 
static void
valuetype_resolvenames(refany name,refany rock)
{
  IDLName n=name;
  IDLDefinition d;
  name_resolvenames(n,rock);
  d=n->value;
  if (d->tag != VALUEtag)
    idl_name_error(n,"not an interface");
}
 
static void
pragma_setversionid(IDLDefinition d,char *value,int do_id)
{
  switch(d->tag){
  case TYPEtag:
  case INTERFACEtag:
  case EXCEPTIONtag:
  case CONSTtag:
  case VALUEtag:
  case VALUEBOXtag:
    if(do_id){
      if(d->id)
	idl_name_error(d->name,"Duplicate ID");
      else d->id=value;
    }else{
      if(d->version)
	idl_name_error(d->name,"Duplicate version");
      else d->version=value;
    }
    if(d->id && d->version)
      idl_name_error(d->name,"Both repository ID and version assigned\n");
    break;
  case NILtag:case OPERATIONtag:case MODULEtag:case MEMBERtag:
  case PARAMETERtag:case ATTRIBUTEtag:case FACTORYtag:case STATEtag:
  case TYPELISTtag:case ATTRLISTtag:case MEMBERLISTtag:case STATELISTtag:
  case CASEtag:case INTERFACEFWDtag:case VALUEFWDtag:case ENUMVALtag:
  case PRAGMA_IDtag:case PRAGMA_VERSIONtag:case PRAGMA_PREFIXtag:
  case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
    idl_name_error(d->name,do_id ? "Invalid assignment of repository ID":
	       "Invalid assignment of repository version");
  }
}

static void definition_precedes (refany, refany);

void
definition_resolvenames(refany def,refany rock)
{
  IDLDefinition d=def;
  switch(d->tag){
    /* those should not happen */
  case NILtag:case TYPELISTtag:case MEMBERLISTtag:case ATTRLISTtag:
  case STATELISTtag:
    break;
  case MODULEtag:
  case ENUMVALtag:
  case FACTORYtag:
  case EXCEPTIONtag:
    break;
  case INTERFACEtag:
    /* bases first, because local definitions might refer to bases */
    switch(d->u.interface.resolution_state){
    case 0:
      /* normal operation, resolve */
      d->u.interface.resolution_state=1;
      list_enumerate(d->u.interface.bases,interface_resolvenames,rock);
      d->u.interface.resolution_state=2;
      /* local definitions below */
      break;
    case 1:
      /* oops, nested call */
      idl_name_error(d->name,"Cycle in base interface resolution");
      break;
    default:break;
    }
    break;
  case VALUEtag:
    list_enumerate(d->u.value.bases,valuetype_resolvenames,rock);
    list_enumerate(d->u.value.bases,definition_precedes,d->name);
    list_enumerate(d->u.value.supports,name_resolvenames,rock);
    break;
  case VALUEBOXtag:
    type_resolvenames(d->u.type,rock);
    break;
  case CONSTtag:
    type_resolvenames(d->u.constant.type,rock);
    value_resolvenames(d->u.constant.val,rock);
    break;
  case OPERATIONtag:
    type_resolvenames(d->u.operation.returntype,rock);
    /* list_enumerate allows for NULL lists */
    list_enumerate(d->u.operation.raises,name_resolvenames,rock);
    break;
  case ATTRIBUTEtag:
    type_resolvenames(d->u.attribute.type,rock);
    break;
  case STATEtag:
    type_resolvenames(d->u.state.type,rock);
    list_enumerate (d->name->array, value_resolvenames, rock);
    break;
  case MEMBERtag:
    type_resolvenames(d->u.member,rock);
    list_enumerate (d->name->array, value_resolvenames, rock);
    break;
  case CASEtag:
    type_resolvenames(d->u._case.type,rock);
    list_enumerate(d->u._case.labels,case_resolvenames,rock);
    list_enumerate (d->name->array, value_resolvenames, rock);
    break;
  case TYPEtag:
    type_resolvenames(d->u.type,rock);
    break;
  case PARAMETERtag:
    type_resolvenames(d->u.parameter.type,rock);
    break;
  case INTERFACEFWDtag:
    /* The corresponding definition has to be an interface,
       and it must be defined in the same scope */
    if(d->env)
      d->name->value=lookup_name_in_scope(d->env,d->name->name);
    else
      d->name->value=list_find(rock,cmp_name,d->name->name);
    if(!d->name->value)
      idl_name_error(d->name,"no interface for forward declaration");
    else if(d->name->value->tag!=INTERFACEtag)
      idl_name_error(d->name,"corresponding definition is not an interface");
    break;
  case VALUEFWDtag:
    if (d->env)
      d->name->value = lookup_name (d->env, d->name->name, rock);
    else
      d->name->value = list_find (rock, cmp_name, d->name->name);
    if (!d->name->value
	|| d->name->value->env != d->env)
      idl_name_error (d->name, "no valuetype for forward declaration");
    else if (d->name->value->tag != VALUEtag) {
      if (d->name->value->tag == VALUEBOXtag)
	idl_name_error (d->name, "value boxes cannot be forward-declared");
      else
	idl_name_error (d->name, "corresponding definition is not a valuetype");
    } else if (d->name->value->u.value.abstract != d->u.value.abstract)
      idl_name_error (d->name, (d->u.value.abstract ?
			    "corresponding valuetype is not abstract" :
			    "corresponding valuetype is abstract"));
    break;
  case PRAGMA_PREFIXtag:case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
    break;
  case PRAGMA_VERSIONtag:
    name_resolvenames(d->name,rock);
    pragma_setversionid(d->name->value,d->u.pragma,FALSE);
    break;
  case PRAGMA_IDtag:
    name_resolvenames(d->name,rock);
    pragma_setversionid(d->name->value,d->u.pragma,TRUE);
    break;
  }
  list_enumerate (get_nested_definitions (d), definition_resolvenames, rock);
}

/************************* check pass        *************************/

static boolean 
identity(refany v1,refany v2)
{
  return v1==v2;
}

static IDLValue value_compute(IDLValue v,list start,IDLName n,IDLType target);
void definition_check(refany def,refany rock);
static IDLType type_compute(IDLType t, IDLValue opt);
static void type_check(IDLType t,IDLName n);

static boolean
isint(enum idltk t)
{
  return t==idl_int || t==idl_octet
    || t==idl_short || t==idl_long || t==idl_long_long 
    || t==idl_unsigned_short || t==idl_unsigned_long || 
    t==idl_unsigned_long_long 
    ;
}

static boolean
isfloat(enum idltk t)
{
  return t==idl_float || t==idl_double;
}

static IDLValue
value_coerce(IDLValue v,IDLType t,IDLName n)
{
  IDLValue v1;
  if(t->tag==BASICtag && v->tag==t->u.basic)
    return v;
  if(t->tag==ENUMtag){
    if(v->tag!=idl_enum)
      idl_name_error(n,"value is not enumerated"); 
    if(type_compute(v->u.enumerated.type, 0)!=t)
      idl_name_error(n,"value is of wrong enumeration");
    return v;
  }
  if(t->tag==STRINGtag){
    if(v->tag!=idl_string)
      idl_name_error(n,"value is not a string");
    return v;
  }
  if(t->tag==WSTRINGtag){
    if(v->tag!=idl_wstring)
      idl_name_error(n,"value is not a wide string");
    return v;
  }
  if(t->tag==FIXEDtag){
    if(v->tag!=idl_fixed)
      idl_name_error(n,"no fixed-point value");
    return v;
  }  
  if(t->tag!=BASICtag)
    idl_name_error(n,"Conversion into complex type not possible");
  if(isint(t->u.basic)){
    boolean ok;
    int I=v->u.INT;
    if(!isint(v->tag))
      idl_name_error(n,"Value is not an integral type");
    switch(t->u.basic){
    case idl_octet:            ok= (      0 <= I) && (I<=0xFF);  break;
    case idl_short:            ok= (-0x8000 <= I) && (I<=0x7FFF);break;
    case idl_unsigned_short:   ok= (      0 <= I) && (I<=0xFFFF);break;
    case idl_long_long: /* FIXME: cannot check long long */
    case idl_long:             ok=(!(I & 0x80000000)); break;
    case idl_unsigned_long_long: /* FIXME: cannot check long long */
    case idl_unsigned_long:    ok=1; break;
    default:
      idl_name_error(0,"Unknown basic type");
    }
    if(!ok)
      idl_name_error(n,"Value out of range");
    v1=new_value();
    *v1=*v;
    v1->tag=t->u.basic;
    return v1;
  }
  if(isfloat(t->u.basic)){
    if(!isfloat(v->tag))
      idl_name_error(n,"Value is not floating point");
    /* FIXME: range check */
    v1=new_value();
    *v1=*v;
    v1->tag=t->u.basic;
    return v1;
  }
  if(t->u.basic==idl_boolean){
    if(v->tag!=idl_boolean)
      idl_name_error(n,"Value is not boolean");
    return v;
  }
  if(t->u.basic==idl_char || t->u.basic==idl_wchar){
    if(v->tag!=idl_char)
      idl_name_error(n,"Value is not a character");
    return v;
  }
  if(t->u.basic==idl_any)
    idl_name_error(n,"Constants of type any are not allowed");
  idl_name_error(n,"Unsupported type for constants");
  return 0;
}

static IDLValue
definition_compute(IDLDefinition d,list start,IDLName n)
{
  if(d->tag==ENUMVALtag)
    return d->u.enumval;
  if(d->u.constant.computed)
    return d->u.constant.val;
  if(list_find(start,identity,d))
    idl_name_error(d->name,"cycle in computation of value");
  if(d->tag!=CONSTtag)
    idl_name_error(n,aprintf("%s is not a constant",d->name->name));
  list_insert(start,d);
  d->u.constant.val=value_compute(d->u.constant.val,start,
				  d->name,type_compute(d->u.constant.type, 0));
  /* in case this was a fixed-point value, need to compute type again */
  d->u.constant.type=type_compute(d->u.constant.type, d->u.constant.val);
  d->u.constant.computed=TRUE;
  return d->u.constant.val;
}

#define MAX_FIXED_PREC 32
static void fixed_sub(IDLValue,IDLValue,IDLValue);

static void 
fixed_zero(char* x)
{
  int i;
  for(i=0;i<MAX_FIXED_PREC;i++)
    x[i]=0;
}

static void
fixed_fill(char* to, char* from)
{
  while (*from)
    *to++ = *from++ -'0';
}

static void
fixed_normalize(IDLValue val)
{
  int i = strlen (val->u.fixed.digits);
  while (val->u.fixed.digits[--i]=='0' && i>0)
    {
      val->u.fixed.digits[i] = '\0';
      val->u.fixed.exponent++;
    }
}  

static void
fixed_add(IDLValue res,IDLValue arg1,IDLValue arg2)
{
  char v1[MAX_FIXED_PREC],v2[MAX_FIXED_PREC];
  int prec1,prec2;
  int msd1, msd2;
  int i,k,ov;
  if (arg1->u.fixed.negative)
    {
      arg1->u.fixed.negative = FALSE;
      fixed_sub(res,arg2,arg1);
      arg1->u.fixed.negative = TRUE;
      return;
    }
  if (arg2->u.fixed.negative)
    {
      arg2->u.fixed.negative = FALSE;
      fixed_sub(res,arg1,arg2);
      arg1->u.fixed.negative = TRUE;
      return;
    }
  fixed_zero(v1);
  fixed_zero(v2);
  prec1 = strlen(arg1->u.fixed.digits);
  prec2 = strlen(arg2->u.fixed.digits);
  msd1 = prec1+arg1->u.fixed.exponent;
  msd2 = prec2+arg2->u.fixed.exponent;
  if (msd1<msd2)
    {
      fixed_fill(v1+msd2-msd1+1, arg1->u.fixed.digits);
      fixed_fill(v2+1,arg2->u.fixed.digits);
      prec1 += msd2-msd1;
    }
  else
    {
      fixed_fill(v2+msd1-msd2+1, arg2->u.fixed.digits);
      fixed_fill(v1+1,arg1->u.fixed.digits);
      prec2 += msd1-msd2;
    }
  for (i=MAX_FIXED_PREC-1, ov=0;i>=0;i--)
    {
      v1[i]+=v2[i]+ov;
      ov = v1[i]/10;
      v1[i] %= 10;
    }
  if (prec1<prec2)
    prec1 = prec2;
  prec1++;
  if (msd1<msd2)
    msd1 = msd2;
  msd1++;
  for (i=0; v1[i]==0; i++)
    msd1--;
  res->u.fixed.digits = iluparser_Malloc (prec1-i+1);
  for (k=0; i<prec1; i++, k++)
    res->u.fixed.digits[k] = '0'+v1[i];
  res->u.fixed.digits[k] = '\0';
  res->u.fixed.exponent = msd1-k;
  res->u.fixed.negative = FALSE;
  fixed_normalize (res);
}

static void
fixed_sub(IDLValue res,IDLValue arg1,IDLValue arg2)
{
  char v1[MAX_FIXED_PREC],v2[MAX_FIXED_PREC];
  int prec1,prec2;
  int msd1, msd2;
  int i,k,ov;
  if (arg2->u.fixed.negative)
    {
      arg2->u.fixed.negative = FALSE;
      fixed_add(res,arg1,arg2);
      arg1->u.fixed.negative = TRUE;
      return;
    }
  if (arg1->u.fixed.negative)
    {
      arg1->u.fixed.negative = FALSE;
      fixed_add(res,arg1,arg2);
      arg1->u.fixed.negative = TRUE;
      res->u.fixed.negative = !res->u.fixed.negative;
      return;
    }
  fixed_zero(v1);
  fixed_zero(v2);
  prec1 = strlen(arg1->u.fixed.digits);
  prec2 = strlen(arg2->u.fixed.digits);
  msd1 = prec1+arg1->u.fixed.exponent;
  msd2 = prec2+arg2->u.fixed.exponent;
  if (msd1<msd2)
    {
      fixed_fill(v1+msd2-msd1+1, arg1->u.fixed.digits);
      fixed_fill(v2+1,arg2->u.fixed.digits);
      prec1 += msd2-msd1;
    }
  else
    {
      fixed_fill(v2+msd1-msd2+1, arg2->u.fixed.digits);
      fixed_fill(v1+1,arg1->u.fixed.digits);
      prec2 += msd1-msd2;
    }
  for (i=MAX_FIXED_PREC-1, ov=0;i>=0;i--)
    {
      v1[i]-=v2[i]+ov;
      if (v1[i]<0)
	{
	  v1[i] += 10;
	  ov = 1;
	}
      else
	ov = 0;
    }
  if (ov)
    {
      /* negative, compute complement */
      res->u.fixed.negative = TRUE;
      for (i=MAX_FIXED_PREC-1, ov=0; i>=0; i--)
	{
	  v1[i] = -ov - v1[i];
	  if (v1[i]<0)
	    {
	      v1[i] += 10;
	      ov = 1;
	    }
	  else
	    ov = 0;
	}
    }
  else
    res->u.fixed.negative = FALSE;
  if (prec1<prec2)
    prec1 = prec2;
  prec1++;
  if (msd1<msd2)
    msd1 = msd2;
  msd1++;
  for (i=0; v1[i]==0; i++)
    msd1--;
  iluparser_Free (res->u.fixed.digits);
  res->u.fixed.digits = iluparser_Malloc (prec1-i+1);
  for (k=0; i<prec1; i++, k++)
    res->u.fixed.digits[k] = '0'+v1[i];
  res->u.fixed.digits[k] = '\0';
  res->u.fixed.exponent = msd1-k;
  fixed_normalize (res);
}

static void
fixed_mul(IDLValue res,IDLValue arg1,IDLValue arg2)
{
  idl_name_error(0,"not implemented: multiplying fixed-point values");
}

static void
fixed_div(IDLValue res,IDLValue arg1,IDLValue arg2)
{
  idl_name_error(0,"not implemented: dividing fixed-point values");
}

static IDLValue
value_compute(IDLValue v,list start,IDLName n,IDLType target)
{
  IDLDefinition named;
  IDLValue v1,v2;
  if(v->value)
    return value_coerce(v->value,target,n);
  switch(v->tag){
  case idl_named:
    named=v->u.named->value;
    v->value=definition_compute(named,start,named->name);
    return value_coerce(v->value,target,n);
  case idl_unary:
    v1=value_compute(v->u.unary.arg,start,n,target);
    if(isint(v1->tag)){
      v->tag=v1->tag;
      switch(v->u.unary.operator){
      case '+':v->u.INT = v1->u.INT;break;
      case '-': /* protect against negative unsigned values! */
	if ((target->tag == BASICtag) && 
	    ((target->u.basic == idl_unsigned_long) ||
	     (target->u.basic == idl_unsigned_short) ||
	     (target->u.basic == idl_unsigned_long_long)
	     )) 	
	  idl_name_error(n,"Invalid negative unsigned value");
	v->u.INT =-v1->u.INT;
	break;
      case '~':v->u.INT =~v1->u.INT;break;
      default:
	idl_name_error(n,"Invalid unary integer operator");
      }
    }else if(isfloat(v1->tag)){
      char op=v->u.unary.operator;
      *v=*v1;
      v->value=0;
      switch(op){
      case '+':break;
      case '-':
	v->u.FLOAT.val=-v->u.FLOAT.val;
	v->u.FLOAT.sign=-v->u.FLOAT.sign;
	break;
      default:
	idl_name_error(n,"Invalid unary float operator");
      }
    }else if(v1->tag == idl_fixed){
      char op=v->u.unary.operator;
      *v=*v1;
      v->value=0;
      switch(op){
      case '+':break;
      case '-':
	v->u.fixed.negative = !v->u.fixed.negative;
	break;
      default:
	idl_name_error(n,"Invalud unary fixed-point operator");
      }
    }else      
      idl_name_error(n,"Invalid operand for unary operator");
    return value_coerce(v,target,n);
  case idl_binary:
    v1=value_compute(v->u.binary.arg1,start,n,target);
    v2=value_compute(v->u.binary.arg2,start,n,target);
    if(isint(v1->tag)){
      v->tag=v1->tag;
      switch(v->u.binary.operator){
	/* FIXME: integer overflow must be detected */
      case '+':v->u.INT = v1->u.INT + v2->u.INT;break;
      case '-':v->u.INT = v1->u.INT - v2->u.INT;break;
      case '*':v->u.INT = v1->u.INT * v2->u.INT;break;
      case '/':v->u.INT = v1->u.INT / v2->u.INT;break;
      case '%':v->u.INT = v1->u.INT % v2->u.INT;break;
      case 'L':v->u.INT = v1->u.INT <<v2->u.INT;break;
      case 'R':v->u.INT = v1->u.INT >>v2->u.INT;break;
      case '&':v->u.INT = v1->u.INT & v2->u.INT;break;
      case '^':v->u.INT = v1->u.INT ^ v2->u.INT;break;
      case '|':v->u.INT = v1->u.INT | v2->u.INT;break;
      default:
	idl_name_error(n,"Invalid binary integer operator");
      }
    }else if(isfloat(v1->tag)){
      char op=v->u.binary.operator;
      v->tag=v1->tag;
      /* literal integral parts not supported here */
      v->u.FLOAT.integer=v->u.FLOAT.fraction=0;
      switch(op){
      case '+':v->u.FLOAT.val = v1->u.FLOAT.val + v2->u.FLOAT.val;break;
      case '-':v->u.FLOAT.val = v1->u.FLOAT.val - v2->u.FLOAT.val;break;
      case '*':v->u.FLOAT.val = v1->u.FLOAT.val * v2->u.FLOAT.val;break;
      case '/':v->u.FLOAT.val = v1->u.FLOAT.val / v2->u.FLOAT.val;break;
      default:
	idl_name_error(n,"Invalid floating point binary operator");
      }
    }else if(v1->tag == idl_fixed){
      char op=v->u.binary.operator;
      v->tag=v1->tag;
      switch (op){
      case '+':fixed_add(v,v1,v2);break;
      case '-':fixed_sub(v,v1,v2);break;
      case '*':fixed_mul(v,v1,v2);break;
      case '/':fixed_div(v,v1,v2);break;
      default:
	idl_name_error(n,"Invalid fixed-point binary operator");
      }
    }else
      idl_name_error(n,"Invalid arguments for binary operators");
    return value_coerce(v,target,n);
  default:
    /* primitive values */
    return value_coerce(v,target,n);
  }
  return 0;
}

static IDLType
type_compute(IDLType t, IDLValue val)
{
  switch(t->tag){
    /* those identify themselves */
  case NULLTYPEtag:case BASICtag:case SEQUENCEtag:case STRINGtag:
  case STRUCTtag:case ARRAYtag:case ENUMtag:case UNIONtag:case WSTRINGtag:
  case NATIVEtag:
    return t;
    /* If a value is given, build type based on value */
  case FIXEDtag:
    {
      IDLValue v;
      if (!val)
	return t;
      assert (val->tag==idl_fixed);
      t = new_type();
      t->tag=FIXEDtag;

      /* compute the number of significant digits */
      v=new_value();
      v->tag=idl_int;
      v->u.INT=strlen(val->u.fixed.digits);
      t->u.fixed.digits=v;

      /* compute the decimal exponent */
      v=new_value();
      v->tag=idl_int;
      v->u.INT=val->u.fixed.exponent;
      t->u.fixed.exponent=v;
      return t;
    }
    /* those is one of the above after one level of indirection */
  case DEFINEDtag:
    return type_compute(t->u.defined->u.type, val);
  case ALIAStag:
    return type_compute(t->u.alias, val);
  case REFERENCEDtag:
    if(t->u.referenced.val)
      return type_compute(t->u.referenced.val, val);
    type_check(t,t->u.referenced.name);
    assert(t->u.referenced.val);
    return type_compute(t->u.referenced.val, val);
  }
  return 0;
}

static boolean
definition_isdefinition(IDLDefinition d)
{
  switch(d->tag){
  case PRAGMA_VERSIONtag:case PRAGMA_IDtag:case PRAGMA_PREFIXtag:
  case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
  case INTERFACEFWDtag:case VALUEFWDtag:
    return FALSE;
  default:
    return TRUE;
  }
}

static void
duplicate_check(refany def1,refany def)
{
  IDLDefinition d1=def1,d=def;
  /* identical definitions, no problem */
  if(def1==def)return;
  /* one or the other does not really define anything */
  if(!definition_isdefinition(d) || !definition_isdefinition(d1))
    return;
  /* different names, no problem */
  if(!cmp_name(d,d1->name->name))return;
  /* for same names, only complain if def is after def1 */
  if(d->name->line<d1->name->line)return;
  idl_name_error(d->name,aprintf("already defined in line %d\n",d1->name->line));
}

static void
dimensions_check(refany val,refany name)
{
  IDLValue v=val;
  list l;
  *v=*value_compute(val,l=iluparser_new_list(),name,the_long_t);
  if(v->u.INT<=0)
    idl_name_error(name,"dimension is not positive");
  /* free temporary list */
  list_clear(l,FALSE);
  iluparser_Free(l);
}

static IDLType
type_resolve(IDLType t,list l,IDLName n)
{
  IDLDefinition d;
  if (t->tag!=REFERENCEDtag) return t;
  if (t->u.referenced.val) return t->u.referenced.val;
  d=t->u.referenced.name->value;
  if (d->tag == INTERFACEtag)
    /* referenced interface */
    return t;
  if (d->tag == VALUEtag || d->tag == VALUEBOXtag)
    /* referenced value */
    return t;
  if (d->tag != TYPEtag) {
    idl_name_error (n, aprintf ("%s does not specify a type",d->name->name));
    return 0;
  }
  if (list_find (l, identity, d))
    idl_name_error (n, "cycle in type resolution");
  list_insert (l, d);
  return d->u.type = type_resolve (d->u.type, l, n);
}

/* Check whether a struct or union contains itself recursively,
   either as member type, or inside nested structures or unions. */

static void
type_recursion (refany field, refany type)
{
  IDLDefinition f = field;
  IDLType t;
  switch (f->tag){
  case MEMBERtag:
    t = f->u.member;
    break;
  case CASEtag:
    t = f->u._case.type;
    break;
  case TYPEtag:
    switch (f->u.type->tag) {
    case STRUCTtag:
      list_enumerate (f->u.type->u.structure, type_recursion, type);
      break;
    case UNIONtag:
      list_enumerate (f->u.type->u._union.body, type_recursion, type);
      break;
    default:
      break;
    }
    /* If iterating over the fields did not find an error, it is ok */
    return;
  default:
    /* Nothing else can happen in a union or struct */
    return;
  }
  if ((t->tag == REFERENCEDtag)
      && (t->u.referenced.val == type))
    idl_name_error (f->name, "recursive type");
}
    
static void
type_check(IDLType t,IDLName n)
{
  list l=0;
  switch(t->tag){
  case NULLTYPEtag:
    /* this should not happen */
  case BASICtag:case ENUMtag:case NATIVEtag:
    /* nothing to do */
  case DEFINEDtag:
    /* those will be checked separately */
    break;
  case ALIAStag:
    type_check(t->u.alias,n);
    break;
  case REFERENCEDtag:
    if(t->u.referenced.val)break;
    t->u.referenced.val=type_resolve(t,l=iluparser_new_list(),n);
    break;
  case SEQUENCEtag:
    type_check(t->u.sequence.type,n);
    if(t->u.sequence.size){
      t->u.sequence.size=
	value_compute(t->u.sequence.size,l=iluparser_new_list(),n,the_long_t);
      if(t->u.sequence.size->u.INT<=0)
	idl_name_error(n,"sequence size is not positive");
    }
    break;
  case STRUCTtag:
    list_enumerate (t->u.structure, definition_check,0);
    list_enumerate (t->u.structure, type_recursion, t);
    break;
  case WSTRINGtag:
  case STRINGtag:
    if(t->u.stringsize){
      t->u.stringsize=
	value_compute(t->u.stringsize,l=iluparser_new_list(),n,the_long_t);
      if(t->u.stringsize->u.INT<=0)
	idl_name_error(n,"string size is not positive");
    }
    break;
  case ARRAYtag:
    type_check(t->u.array.type,n);
    list_enumerate(t->u.array.dimensions,dimensions_check,n);
    break;
  case FIXEDtag:
    if(t->u.fixed.digits){
      list l1;
      t->u.fixed.digits=
	value_compute(t->u.fixed.digits,l=iluparser_new_list(),n,the_long_t);
      t->u.fixed.exponent=
	value_compute(t->u.fixed.exponent,l1=iluparser_new_list(),
		      n,the_long_t);
      if(t->u.fixed.digits->u.INT<=0)
	idl_name_error(n,"number of digits not positive");
      list_clear(l1,FALSE);
      iluparser_Free(l1);
      /* l will be cleared below */
    }
    break;
  case UNIONtag:
    type_check (t->u._union.head, n);
    t->u._union.labels = iluparser_new_list ();
    list_enumerate (t->u._union.body, definition_check, 0);
    list_enumerate (t->u._union.body, type_recursion, t);
    break;
  }
  if(l){
    /* free temporary list */
    list_clear(l,FALSE);
    iluparser_Free(l);
  }
}

static boolean
equal_value (refany V1, refany V2)
{
  IDLValue v1 = V1;
  IDLValue v2 = V2;
  assert (v1->tag == v2->tag);
  switch (v1->tag){
    /* Not legal switch types */
  case idl_void:case idl_float:case idl_double:
  case idl_wstring:case idl_any:case idl_string:case idl_object:
  case idl_valuebase:
    /* Those cannot happen */
  case idl_int:case idl_fixed:
  case idl_unary:case idl_binary:case idl_named:
    return TRUE;

  case idl_short:case idl_long:case idl_unsigned_short:
  case idl_unsigned_long:case idl_octet:
  case idl_long_long:case idl_unsigned_long_long:
    return v1->u.INT == v2->u.INT;
  case idl_wchar:
  case idl_char:
    return v1->u.CHAR == v2->u.CHAR;
  case idl_boolean:
    return v1->u.BOOL == v2->u.BOOL;
  case idl_enum:
    return v1->u.enumerated.name == v2->u.enumerated.name;
  }
  return FALSE;
}

static void
caselabel_check(refany label,refany Union)
{
  IDLCase c=label;
  IDLDefinition u=Union;
  IDLName n=c->env->name;
  list l;
  if(c->value){
    c->value=value_compute(c->value,l=iluparser_new_list(),
			   n,type_compute(u->u.type->u._union.head,0));
    list_clear(l,FALSE);
    iluparser_Free(l);
    if (list_find (u->u.type->u._union.labels, equal_value, c->value))
      idl_name_error (n, "duplicate case label");
    list_insert (u->u.type->u._union.labels, c->value);
  }else{ /*default*/
      IDLName n1=u->u.type->u._union._default;
      if(n1 && n!=n1)
	idl_name_error(n,aprintf("default branch already assigned to %s",
			     n1->name));
      else
	u->u.type->u._union._default=n;
  }
}

/* compare location of base interface definition with this interface */
static void
definition_precedes(refany base,refany derived)
{
  IDLName d=derived;
  IDLName b=base;
  if(b->value->name->serial >= d->serial)
    idl_name_error(b,"base interface must precede derived one");
}

/* helper for error message */
static IDLDefinition current_interface;

static char*
i_or_v (IDLDefinition d)
{
  if (d->tag == INTERFACEtag)
    return "interface";
  return "value";
}

/* merge an operation in l, complain if it is already there */
static void
collect_operations1(refany def,refany l)
{
  IDLDefinition d=def;
  IDLDefinition d1;
  if(d->tag!=OPERATIONtag)return;
  if((d1=list_find(l,cmp_name,d->name->name)))
    idl_name_error(d->name,
		   aprintf("When defining %s %s, "
			   "operation conflicts with %s %s\n",
			   i_or_v (current_interface),
			   current_interface->name->name,
			   i_or_v (d1->env),
			   d1->env->name->name));
  else
    list_insert(l,d);
}
			       
/* merge the definitions of one base interface into l */
static void
collect_operations(refany base,refany l)
{
  IDLName b=base;
  list_enumerate (get_nested_definitions (b->value), collect_operations1, l);
}

/* check whether the raises clause contains only exceptions */
static void
exception_check(refany e, refany rock)
{
  IDLName E=e;
  assert(E->value);
  if (E->value->tag != EXCEPTIONtag)
    idl_name_error (E, "not an exception");
}

/* check whether a base is not abstract */
static void
inheritance_check (refany base, refany rock)
{
  IDLDefinition b = base;
  if (!b->u.interface.abstract)
    idl_name_error (b->name, "not an abstract interface");
}

struct vcheck{
  IDLDefinition v;
  int baseno;
};

/* check for value inheritance restrictions */
static void
vinheritance_check(refany b, refany rock)
{
  struct vcheck *check = rock;
  IDLName B = b;
  check->baseno++;
  /* Bases must be values. */
  if (B->value->tag != VALUEtag){
    idl_name_error (B, "not a value");
    return;
  }
  if (check->baseno == 1){
    /* First base: If it is a concrete value,
       the derived value must be concrete. */
    if (check->v->u.value.abstract && !B->value->u.value.abstract)
      idl_name_error (B, "concrete base for abstract value");
    /* Non-custom values may not inherit from custom values */
    if (!check->v->u.value.custom && B->value->u.value.custom)
      idl_name_error (B, "custom base for non-custom value");
  }else{
    /* Other bases must be abstract. */
    if (!B->value->u.value.abstract)
      idl_name_error (B, "more than one concrete base for value");
  }
}

/* check whether n names an interface */
static void
interface_check(refany name, refany rock)
{
  IDLName n = name;
  struct vcheck * check = rock;
  check->baseno++;
  if (n->value->tag != INTERFACEtag)
    idl_name_error (n, "not an interface");
  /* At most the first interface may be non-abstract */
  if ((check->baseno != 1) && !n->value->u.interface.abstract)
      idl_name_error (n, "not an abstract interface");
}

/* Check whether an interface appears twice in a base list. */
static boolean
equal_bases (refany name, refany orig)
{
  IDLName n = name;
  IDLName o = orig;
  /* We'll definitely find ourselves identically. */
  if (name == orig)
    return FALSE;
  /* If it's not the same definition, that's ok. */
  if (n->value != o->value)
    return FALSE;
  return TRUE;
}

static void
duplicate_bases (refany base, refany bases)
{
  IDLName n = base;
  if (list_find (bases, equal_bases, base))
    idl_name_error (n, "Listed twice as a base");
}

static void
oneway_outparam (refany param, refany rock)
{
  IDLDefinition p = param;
  if (p->u.parameter.direction == Out)
      idl_name_error (p->name, "invalid out parameter in oneway operation");
  if (p->u.parameter.direction == InOut)
      idl_name_error (p->name, "invalid inout parameter in oneway operation");
}

static void
oneway_check (IDLDefinition d)
{
  if (d->u.operation.returntype->tag != BASICtag
      || d->u.operation.returntype->u.basic != idl_void)
      idl_name_error (d->name, "oneway operation must not return a value");
  list_enumerate (d->u.operation.parameters, oneway_outparam, d->name);
}

/* Check whether the name of a definition is defined directly in the
   definition as well. */
static void
inner_name_check (IDLDefinition d)
{
  IDLDefinition i = lookup_name_in_scope (d, d->name->name);
  if (i)
    idl_name_error (i->name, "invalid immediate reuse of name");
}   
    
void 
definition_check(refany def,refany rock)
{
  IDLDefinition d=def;
  list l=0;
  list_enumerate(rock,duplicate_check,d);
  switch(d->tag){
  case NILtag:case TYPELISTtag:case MEMBERLISTtag:case ATTRLISTtag:
  case STATELISTtag:
    /* this should not happen */
    break;
  case PRAGMA_IDtag:case PRAGMA_VERSIONtag:case PRAGMA_PREFIXtag:
  case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
    /* nothing to do */
    break;
  case MODULEtag:
    /* Name reuse rule */
    inner_name_check (d);
    break;
  case INTERFACEtag:
    /* base interfaces must appear before derived */
    list_enumerate(d->u.interface.bases,definition_precedes,d->name);

    /* base interfaces must not share operation names */
    current_interface=d;
    l=iluparser_new_list();
    list_enumerate(d->u.interface.bases,collect_operations,l);
    /* now also check our own operations */
    list_enumerate(d->u.interface.definitions,collect_operations1,l);

    current_interface=0;
    /* abstract interfaces must not have concrete bases */
    if (d->u.interface.abstract)
      list_enumerate (d->u.interface.bases,inheritance_check,NULL);
    /* Base interfaces must not be listed twice */
    list_enumerate (d->u.interface.bases, duplicate_bases, d->u.interface.bases);
    /* Name reuse rule */
    inner_name_check (d);
    break;
  case VALUEtag:
    {
      struct vcheck check;
      /* base types must appear before derived */
      list_enumerate(d->u.value.bases,definition_precedes,d->name);
      list_enumerate(d->u.value.supports,definition_precedes,d->name);
      /* There are a number of restrictions on inheritance. */
      check.v = d;
      check.baseno = 0;
      list_enumerate(d->u.value.bases, vinheritance_check, &check);
      check.baseno = 0;
      list_enumerate (d->u.value.supports, interface_check, &check);
      if (d->u.value.custom && d->u.value.truncatable)
	idl_name_error (d->name, "custom value must not be truncatable");

      /* base values must not share operation names */
      current_interface = d;
      l=iluparser_new_list();
      list_enumerate(d->u.value.bases,collect_operations,l);
      /* also add operations of supported interfaces */
      list_enumerate(d->u.value.supports,collect_operations,l);
      /* now also check our own operations */
      list_enumerate(d->u.interface.definitions,collect_operations1,l);

      /* Name reuse rule */
      inner_name_check (d);
      break;
    }
  case VALUEBOXtag:
    type_check (d->u.type,d->name);
    break;
  case INTERFACEFWDtag:
  case VALUEFWDtag:
    break;
  case EXCEPTIONtag:
    /* Name reuse rule */
    inner_name_check (d);
    break;
  case CONSTtag:
    /* FIXME: type_check(d->u.constant*/
    definition_compute(d,l=iluparser_new_list(),d->name);
    break;
  case TYPEtag:
    type_check(d->u.type,d->name);
    /* Name reuse rule */
    inner_name_check (d);
    break;
  case OPERATIONtag:
    type_check(d->u.operation.returntype, d->name);
    list_enumerate(d->u.operation.raises,exception_check,0);
    if (d->u.operation.oneway)
      oneway_check (d);
    break;
  case FACTORYtag:
    break;
  case PARAMETERtag:
    type_check(d->u.parameter.type,d->name);
    break;
  case ATTRIBUTEtag:
    type_check(d->u.attribute.type,d->name);
    break;
  case STATEtag:
    type_check(d->u.state.type,d->name);
    list_enumerate (d->name->array, dimensions_check, d->name);
    break;
  case MEMBERtag:
    type_check(d->u.member,d->name);
    list_enumerate (d->name->array, dimensions_check, d->name);
    break;
  case CASEtag:
    type_check(d->u._case.type,d->name);
    list_enumerate(d->u._case.labels,caselabel_check,d->env);
    list_enumerate (d->name->array, dimensions_check, d->name);
    break;
  case ENUMVALtag:
    break;
  }
  list_enumerate(get_nested_definitions (d), definition_check,
		 get_nested_definitions (d));
  if(l){
    /* free list */
    list_clear(l,FALSE);
    iluparser_Free(l);
  }
}

/************************* setuid pass       *************************/

refany 
list_top (list l)
{
  if (!l || !l->head)
    return NULL;
  return l->head->data;
}

void
list_settop (list l, refany val)
{
  if (l->head)
    l->head->data = val;
}

void
list_pop (list l)
{
  if (l->head){
    l->head = l->head->next;
    if (!l->head)
      l->tail = NULL;
    l->count --;
  }
}

void definition_setuid(refany def,refany list);

static void
type_setuid(IDLType t,list p)
{
  list nested = 0;
  switch(t->tag){
    /* those don't have anything with uids inside */
  case NULLTYPEtag:
  case BASICtag:
  case REFERENCEDtag:
  case ENUMtag:
  case ALIAStag:
  case NATIVEtag:
    break;
    /* FIXME: anonymous types don't get a repository id, yet */
  case ARRAYtag:
  case SEQUENCEtag:
  case STRINGtag:
  case WSTRINGtag:
  case FIXEDtag:
    break;
  case UNIONtag:
    type_setuid(t->u._union.head,p);
    nested = t->u._union.body;
    break;
  case STRUCTtag:
    nested = t->u.structure;
    break;
  case DEFINEDtag:
    definition_setuid(t->u.defined,p);
    break;
  }
  if (nested) {
    list_enumerate (nested, definition_setuid, p);
  }
}

void
definition_setuid(refany def,refany p)
{
  list nested = 0;
  IDLDefinition d=def;
  char *prefix = list_top (p);
  list newprefix = iluparser_new_list ();

  if (d->name) {
    if (prefix && *prefix)
      prefix = aprintf("%s/%s",prefix,d->name->name);
    else
      prefix = d->name->name;
    list_push (newprefix, prefix);
    if (!d->id){
      d->id = aprintf("IDL:%s:%s", 
		      list_top (newprefix), 
		      d->version?d->version:"1.0");
    }
  }

  switch (d->tag){
  case NILtag:case TYPELISTtag:case ATTRLISTtag:case MEMBERLISTtag:
  case STATELISTtag:
    idl_name_error(d->name,"Unexpected case in definition_setuid");
    break;
    /* those don't have anything with uids inside */
  case INTERFACEFWDtag:case PARAMETERtag:case MEMBERtag:case CONSTtag:
  case ENUMVALtag:case CASEtag:case VALUEFWDtag:
    break;
  case MODULEtag:
    nested = d->u.module.definitions;
    break;
  case PRAGMA_PREFIXtag:
    list_settop (p, d->u.pragma);
    break;
  case PRAGMA_PREFIX_PUSHtag:
    list_push (p, "");
    break;
  case PRAGMA_PREFIX_POPtag:
    list_pop (p);
    break;
  case VALUEBOXtag:
    type_setuid (d->u.type, p);
    break;
  case INTERFACEtag:
    nested = d->u.interface.definitions;
    break;
  case VALUEtag:
    /* FIXME: hash */
    nested = d->u.value.definitions;
    break;
  case TYPEtag:
    type_setuid(d->u.type,newprefix);
    break;
  case EXCEPTIONtag:
    nested = d->u.exception.members;
    break;
    /* those don't have repository ids */
  case OPERATIONtag:
  case FACTORYtag:
  case ATTRIBUTEtag:
  case STATEtag:
  case PRAGMA_IDtag:
  case PRAGMA_VERSIONtag:
    return;
  }
  if (nested){
    list_enumerate (nested, definition_setuid, newprefix);
  } 
}

/************************* AB style guide pass ***********************/
/* Paragraph numbers are relative to ab/98-06-03 */
static void definition_style (refany def, refany rock);

static void
name211(IDLDefinition d)
{
  char *n = d->name->name;
  if (!isupper (n[0]))
    name_warning(d->name, "first letter not uppercase (style guide)");
  for (; *n; n++)
    if (!isalpha (*n)){
      name_warning (d->name, "only letters allowed here (style guide)");
      return;
    }
}

static void
name212(IDLDefinition d)
{
  char *n = d->name->name;
  if (!islower (n[0]))
    name_warning(d->name, "first letter not lowercase (style guide)");
  while (*n && n++)
    if (!islower (*n) && *n != '_'){
      name_warning (d->name, "only lowercase and _ allowed here (style guide)");
      return;
    }
}

static void
name213(IDLDefinition d)
{
  char *n = d->name->name;
  if (!isupper (n[0]))
    name_warning(d->name, "first letter not uppercase (style guide)");
  for (; *n; n++)
    if (!isupper (*n) && *n != '_'){
      name_warning (d->name, "only uppercase and _ allowed here (style guide)");
      return;
    }
}

static void
type_style (IDLDefinition d)
{
  IDLType t = d->u.type;
  switch (t->tag){
  case ENUMtag:
  case ALIAStag:
    name211(d);
    break;
  case STRUCTtag:
    name211(d);
    list_enumerate (t->u.structure, definition_style, 0);
    break;
  case UNIONtag:
    name211(d);
    list_enumerate (t->u._union.body, definition_style, 0);
    break;
  default:
    /* some compilers need a statement after default: */;
 }
}

static char* well_known_modules[] = {
  /* FIXME: Fill list */
  0
};

/* 1.1/2 */

static void
nested_module_style (IDLDefinition d)
{
  int i;
  for (i = 0; well_known_modules[i]; i++)
    if (strcmp (d->name->name, well_known_modules[i]) == 0)
      name_warning (d->name, "conflicts with well-known module (style guide)");
}

static void
definition_style (refany def, refany rock)
{
  IDLDefinition d = def;
  switch (d->tag){
  case MODULEtag:
    if (d->env)
      nested_module_style (d);
    /* fall through */
  case INTERFACEtag:
  case VALUEtag:
  case EXCEPTIONtag:
    name211 (d);
    break;
  case OPERATIONtag:
  case ATTRIBUTEtag:
  case PARAMETERtag:
  case STATEtag:
  case MEMBERtag:
  case CASEtag:
    name212 (d);
    break;
  case ENUMVALtag:
  case CONSTtag:
    name213 (d);
    break;
  case TYPEtag:
    type_style (def);
    break;
  }
}

/* 1.1/1 */

void ab_style (refany def, refany rock)
{
  IDLDefinition d = def;
  if (!(idl_subset & IDL_STYLE_GUIDE))
    return;
  switch (d->tag) {
    /* Those are ok on top-level */
  case MODULEtag:
  case PRAGMA_IDtag:
  case PRAGMA_VERSIONtag:
  case PRAGMA_PREFIXtag:
  case PRAGMA_PREFIX_PUSHtag:case PRAGMA_PREFIX_POPtag:
    break;
  default:
    name_warning (d->name, "not in a module (style guide)");
  }
  definition_style (def, rock);
}
