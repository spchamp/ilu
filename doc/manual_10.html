<!-- This HTML file has been created by timdif2html 1.11
     from manual.dif on 20 September 1999 -->

<TITLE>ILU Reference Manual - Using ILU with Perl</TITLE>
<BODY TEXT=#000000 BGCOLOR=#ffffff>
<P>Go to the <A HREF="manual_9.html">previous</A>, <A HREF="manual_11.html">next</A> section.<P>
<H1><A NAME="SEC393" HREF="manual_toc.html#SEC393">Using ILU with Perl</A></H1>
<P>
<A NAME="IDX657"></A>
<H2><A NAME="SEC394" HREF="manual_toc.html#SEC394">Introduction</A></H2>
This document is for the Perl programmer who wishes to use 
ILU. The following sections will show how ILU is
mapped into Perl constructs and how both Perl
clients and servers are generated and built.
<P>
<H2><A NAME="SEC395" HREF="manual_toc.html#SEC395">The ISL Mapping to Perl</A></H2>
<P>
<A NAME="IDX658"></A>
<H3><A NAME="SEC396" HREF="manual_toc.html#SEC396">Names</A></H3>
In general, ILU constructs Perl symbols from
ISL names by replacing hyphens with underscores.
For example, an ISL object type <CODE>T-1</CODE> would correspond to
the Perl class <CODE>T_1</CODE>.
Any place an ISL name appears as part or all of a Perl
identifier, this translation occurs.
<P>
<H3><A NAME="SEC397" HREF="manual_toc.html#SEC397">Interface</A></H3>
Each ISL <CODE>interface</CODE> <CODE><VAR>I</VAR></CODE>
generates a Perl module named <CODE><VAR>I</VAR></CODE> which,
when loaded with <CODE>use I</CODE> stores information about that interface and
adds hooks for client side stubs.
For example,
<CODE>INTERFACE map-test;</CODE> generates the Perl module
<CODE>map_test</CODE> contained in the file <TT>`map_test.pm'</TT>.
<P>
<H3><A NAME="SEC398" HREF="manual_toc.html#SEC398">Basic Types</A></H3>
The basic ISL types have the following mapping to Perl
types:
<P>
<OL>
<LI>
BYTE,
BOOLEAN,
SHORT CHARACTER,
CHARACTER,
SHORT INTEGER,
INTEGER,
SHORT CARDINAL,
SHORT REAL,
CARDINAL,
and REAL
all map to Perl scalars.
<LI>
LONG INTEGER,
LONG CARDINAL,
and LONG REAL
are not yet supported.
</OL>
<P>
<H4><A NAME="SEC399" HREF="manual_toc.html#SEC399">Constant</A></H4>
ISL constants translate to
Perl subs which return the specified value.
For example,
<PRE>
CONSTANT pi : real = 3.14159265358979323846;
</PRE>
maps to
<PRE>
sub pi { 3.14159265358979323846e0; }
</PRE>
<P>
<H3><A NAME="SEC400" HREF="manual_toc.html#SEC400">Strings</A></H3>
An ISL <CODE>SEQUENCE OF SHORT CHARACTER</CODE> maps into a Perl
string.  <CODE>SEQUENCE OF BYTE</CODE> is also mapped into a Perl string.
<P>
<H3><A NAME="SEC401" HREF="manual_toc.html#SEC401">Pickles and Typecodes (Current COPE-ish interface, may change)</A></H3>
A value corresponding to the ISL type <CODE>PICKLE</CODE> is an hash
reference with two keys, <CODE>_type</CODE> and <CODE>_value</CODE>, where
<CODE>$typecode-&#62;{_type}</CODE> is an object of the Perl class
<CODE>ILU::Typecode</CODE> and <CODE>$typecode-&#62;{_value}</CODE> is the
Perl form of the value.
<P>
Typecodes are represented by the Perl class
<CODE>ILU::Typecode</CODE>.  Typecodes are constructed with a single string
argument, of the form <CODE>'<VAR>interface</VAR>.<VAR>type</VAR>'</CODE>, where
<VAR>interface</VAR> is the ISL name for the interface, and
<VAR>type</VAR> is the ISL name for the type.  Instances of
the <CODE>Typecode</CODE> class support the method
<P>
<UL>
<LI><CODE>id()</CODE> - return the ILU type ID (CORBA repository ID) for the typecode's type.
<LI><CODE>name()</CODE> - return the ISL name of the typecode's type.
</UL>
<P>
<H3><A NAME="SEC402" HREF="manual_toc.html#SEC402">Pickles and Typecodes (Possible ILU-ish interface)</A></H3>
A value corresponding to the ISL type <CODE>PICKLE</CODE> is an
instance of the Perl class <CODE>ILU::Pickle</CODE>.  Instances of
this class have the following methods:
<P>
<UL>
<LI><CODE>typecode()</CODE> - returns the typecode of the pickle's value as a string.
<LI><CODE>value()</CODE> - returns the Perl form of the value in the pickle.
<LI><CODE>bytes()</CODE> - the pickled bytes of the pickled value as a string.
</UL>
<P>
The constructor for this class takes two arguments, <VAR>typecode</VAR> and <VAR>value</VAR>,
and returns
a new pickle containing the value specified by <VAR>value</VAR> of the ISL type
specified by <VAR>typecode</VAR>.  Pickles may also be created by calling the constructor
with a single argument string, which must be the result of an earlier call on the <CODE>bytes()</CODE>
method of another pickle instance.
<P>
Typecodes are represented by the Perl class <CODE>ILU::Typecode</CODE>.  Typecodes are constructed
with a single string argument, 
of the form <CODE>'<VAR>interface</VAR>.<VAR>type</VAR>'</CODE>, where
<VAR>interface</VAR> is the ISL name for the interface, and <VAR>type</VAR> is the
ISL name for the type.  Instances of the <CODE>Typecode</CODE> class support the method
<P>
<UL>
<LI><CODE>id()</CODE> - return the ILU type ID (CORBA repository ID) for the typecode's type.
<LI><CODE>name()</CODE> - return the ISL name of the typecode's type.
</UL>
<P>
<H3><A NAME="SEC403" HREF="manual_toc.html#SEC403">Constructed Types</A></H3>
<P>
<H4><A NAME="SEC404" HREF="manual_toc.html#SEC404">Enumeration</A></H4>
Enumarations are mapped into Perl strings that are automatically
mapped into the appropriate values when marshalled and unmarshalled.
(This may change).
<P>
For example, the elements
<PRE>
TYPE color = ENUMERATION red, dark-blue END;
</PRE>
are represented in Perl by <CODE>'red'</CODE> and <CODE>'dark-blue'</CODE>.
<P>
<H4><A NAME="SEC405" HREF="manual_toc.html#SEC405">Array</A></H4>
An ISL array maps into a Perl list with the
specified number of elements. Multi-dimensional arrays map into
arrays of arrays.
Arrays of BYTE or SHORT CHARACTER are represented by Perl strings.
<P>
<H4><A NAME="SEC406" HREF="manual_toc.html#SEC406">Sequence</A></H4>
An ISL sequence of short character maps into a Perl
string.
<P>
All other ISL sequence types map into Perl lists.
Sequences of BYTE or SHORT CHARACTER are represented as Perl strings.
<P>
<H4><A NAME="SEC407" HREF="manual_toc.html#SEC407">Record</A></H4>
ISL records map into references Perl hashes with
the same name, with the record's field names as keys.  
<P>
For example, a record value of the ISL type:
<PRE>
TYPE segment = RECORD left-limit : integer, right-limit : integer END;
</PRE>
with a left-limit of -3 and a right-limit of 7 would map to
<PRE>
{ left-limit =&#62; -3, right-limit =&#62; 7 }
</PRE>
<P>
<H4><A NAME="SEC408" HREF="manual_toc.html#SEC408">Union</A></H4>
An ISL union maps into a Perl list reference with two
components,:
a discriminator, and the discriminated value.
There are three possibilities:
<OL>
<LI>
If the discriminator matches one of the union case values of an arm,
the second component is of the type specified by that arm.
<LI>
If the discriminator matches no union case values and there is a default arm,
the second component is of the type specified by the default arm.
<LI>
If the discriminator matches no union case values and there is no default arm
but the union has the <CODE>OTHERS</CODE> attribute,
the second component is <CODE>undef</CODE>.
</OL>
If the union has a default arm, then it may also be passed from
Perl as a scalar of the default type.
<P>
<H4><A NAME="SEC409" HREF="manual_toc.html#SEC409">Optional</A></H4>
A value corresponding to the ISL type <CODE>OPTIONAL <VAR>T</VAR></CODE>
may be <CODE>undef</CODE> (indicating the null case) in addition to the values of the
type <VAR>T</VAR>.
<P>
<H3><A NAME="SEC410" HREF="manual_toc.html#SEC410">Object Types</A></H3>
Each ISL object type is mapped into a Perl class.
These classes have the methods specified in the ISL, as well as
some built-ins.
<P>
<H4><A NAME="SEC411" HREF="manual_toc.html#SEC411">Surrogate and True Object Types</A></H4>
<P>
Both surrogate and real types inherit from <CODE>ILU::Object</CODE>.  The
method <CODE>ilu_true_p()</CODE> will return a true value on true instances,
and a false value on surrogate instances.  The string binding handle of
an object instance can be retrieved with the method <CODE>ilu_sbh()</CODE>.
The object-id of an instance can be retrieved with
<CODE>ilu_object_id()</CODE>; it returns two values, the string server ID and
a string instance-handle.  If support for the CORBA
<CODE>IIOP</CODE> is configured into your ILU build (in fact,
this will always must be the case for Perl, at least for now), the
string IOR of an instance can be retrieved by calling the method
<CODE>ilu_ior()</CODE>. The type name of the most specific type of an instance
can be retrieved with the method <CODE>ilu_type_name()</CODE>; the unique ID
of that type can be retrieved with the method <CODE>ilu_type_id()</CODE>.
<P>
Object types which inherit from the ISL type
<CODE>ilu.CORBA-Object</CODE> (which include all object types defined with
OMG IDL), will inherit from the Perl class
<CODE><CODE>ILU::CORBA_Object</CODE></CODE>.
<P>
<H4><A NAME="SEC412" HREF="manual_toc.html#SEC412">Methods, Parameters, and Exceptions</A></H4>
<P>
ISL methods of an object type map to Perl methods
of the corresponding class. <CODE>IN</CODE> and <CODE>INOUT</CODE> parameters appear
in the Perl method signature in the same order as they do in
ISL. <CODE>INOUT</CODE> arguments are passed as references to the
type of variable they would normally be mapped into, even when that type
is already a reference. This is meant to avoid complicated rules about
when an extra reference will be added, but it may possibly be changed in
the future, so that array references (ISL array and sequence
types) and hash references (ISL records) do not get the extra
reference.
<P>
Let us define a <EM>result</EM> value to be either a return value
(corresponding to a method's return type) or an <CODE>OUT</CODE> parameter.
All result values are returned by the Perl method, with the
return value (if present) appearing before any parameters.
<P>
Exceptions are implemented using the package <CODE>Error</CODE> An
ISL exception translates to a Perl package whose
name is that of the exception (translated as in the section Names
above). These packages inherit from <CODE>ILU::Exception</CODE>, which in turn
inherits from <CODE>Error</CODE>. To raise an exception, use <CODE>throw</CODE>. To
catch one, use <CODE>try {} catch {} </CODE>.
<P>
For example, the declaration
<PRE>
EXCEPTION division-by-zero : REAL;
</PRE>
in the interface <CODE>map-test</CODE> maps to the following statement in
<TT>`map_test.pm'</TT>:
<PRE>
Package map_test::division_by_zero;
@map_test::division_by_zero::ISA = qw(ILU::Exception);
</PRE>
<P>
To raise this exception, use:
<PRE>
throw map_test::division_by_zero ($numerator);
</PRE>
<P>
To catch it, use:
<PRE>
try {
    $result = $calculator-&#62;divide(3/0);
}
catch map_test::division_by_zero with {
    print $_[0]-&#62;value," was divided by 0\n";
};
</PRE>
<P>
<CODE>ASYNCHRONOUS</CODE> methods have no return values and raise no
user-specified exceptions.  They may return before the completion of the
true method.  <CODE>FUNCTIONAL</CODE> methods that have no parameters can be
cached so that a surrogate address space makes only one call to the true
address space to retrieve the return value.
<P>
<H4><A NAME="SEC413" HREF="manual_toc.html#SEC413">Garbage Collection and COLLECTIBLE</A></H4>
<P>
All instances of ILU object types are covered by the normal
Perl garbage collection; i.e., the application program must
maintain a reference to the instance, or it will be garbage collected.
With true instances of COLLECTIBLE object types, the ILU kernel
will maintain an additional reference to the instance as long as it has
registered clients using that instance.
<P>
<H2><A NAME="SEC414" HREF="manual_toc.html#SEC414">Access to standard ILU features</A></H2>
<P>
<H3><A NAME="SEC415" HREF="manual_toc.html#SEC415">Servers and Ports</A></H3>
<P>
Each object exported by an implementation must belong to a true server,
an instance of the Perl type <CODE>ILU::Server</CODE> which is
implemented by the ILU runtime.
An <CODE>Server</CODE> can be created by calling <BR> 
<CODE>new ILU::Server [<VAR>serverID</VAR> [, <VAR>transport</VAR> [, <VAR>protocol</VAR> [, <VAR>objectTable</VAR>]]]]</CODE>.<BR>
If <VAR>serverID</VAR> is a string, it specifies the server ID;
if it is <CODE>undef</CODE>, one will be invented automatically.
The <VAR>transport</VAR> argument is either a sequence of strings, chosen to
be compatible with the <VAR>protocol</VAR>, or <CODE>undef</CODE> to let it default.
The <VAR>protocol</VAR> argument is either a string specifying a particular
RPC protocol, or <CODE>undef</CODE> to choose the default.  Additional ports
can be added to a server with the <CODE><CODE>add_port()</CODE></CODE> method,
if an application needs to make it available with via multiple protocols
or addresses.
<P>
The first time a true server is created, it becomes the default server.
The default server is used for an exported object if a server is not
otherwise specified.
If an object is exported before any servers have been created,
one will be created automatically using default parameters and a message
to that effect will be written to stderr.
<P>
An object of type <CODE>ILU::Server</CODE> has the following methods:
<UL>
<LI><CODE>id()</CODE> - returns the ILU server ID of the server.
<LI><CODE>add_port(<VAR>TINFO</VAR>, <VAR>PINFO</VAR>)</CODE> - adds another port to the server with the specified
<VAR>TINFO</VAR> and <VAR>PINFO</VAR>.
<LI><CODE>create_serializer()</CODE> - creates and returns a serialization context.
</UL>
<P>
<H4><A NAME="SEC416" HREF="manual_toc.html#SEC416">Object Tables</A></H4>
<P>
The <VAR>objectTable</VAR> argument allows specification of a callback
function (code reference) for creating true instances on demand.  The
callback function should take one argument, a string, which is the
instance handle of the instance to be created, and return a true instance.
<P>
<H3><A NAME="SEC417" HREF="manual_toc.html#SEC417">Threading and Event Loops</A></H3>
<P>
To use threads, you must have configured both ILU and
Perl with thread support when building them, and the thread
support must be compatible. (That is, if Perl is compiled for
POSIX threads, ILU must be as well. Perl FAKETHREADS
will not work.)  If you have done this, your ILU/Perl runtime
support will be thread-capable.  To have ILU begin using
threads, place a call to the function <CODE>ILU-&#62;ThreadedOperation()</CODE> in
your Perl program before any other ILU calls are
made, and before calling <CODE>use</CODE> for any interfaces generated by the
stubber. Since <CODE>use</CODE> is done at compile-time, that means 
the call to <CODE>ILU-&#62;ThreadedOperation()</CODE> needs to occur in a
<CODE>BEGIN{}</CODE> block.
<P>
<H4><A NAME="SEC418" HREF="manual_toc.html#SEC418">Animating Servers</A></H4>
To bring the true servers to life, run the ILU main loop by
creating a new <CODE>ILU::MainLoop</CODE> and calling
<CODE>$mainloop-&#62;run()</CODE>.  This function does not return until
<CODE>$mainloop-&#62;exit()</CODE> is called.  (It is also possible to use
the <CODE>ILU::Gtk</CODE> module to use the GTK main loop 
instead of the native ILU mainloop.)
<P>
<H4><A NAME="SEC419" HREF="manual_toc.html#SEC419">Using Alarms</A></H4>
In order to schedule a Perl function to be called at a
certain time in the future when executing the ILU main loop, an
<CODE>ILU::Alarm</CODE> may be used.  Objects of this type are created by
calling <CODE>new ILU::Alarm()</CODE>.  An <CODE>ILU::Alarm</CODE> must be set to
have any effect.
<P>
The alarm's method <CODE>set(<VAR>time</VAR>, <VAR>proc</VAR>, <VAR>args</VAR>)</CODE> is used to set the
alarm.  The numeric or <CODE>ILU::FineTime</CODE> <VAR>time</VAR> argument is
the time at which the alarm will fire; the <VAR>proc</VAR> argument is the
Perl function that will be called when the alarm fires; and
<VAR>args</VAR> is a list of arguments will be passed to <VAR>proc</VAR>.  
<P>
The function <CODE>ILU::FineTime-&#62;now()</CODE> may be called to obtain
ILU's idea of the current time.  A value <CODE>$sec</CODE> of type in
units of (possible fractional) seconds may be converted to type
<CODE>ILU::FineTime</CODE> by calling <CODE>new ILU::FineTime($sec)</CODE>.
Values of type <CODE>ILU::FineTime</CODE> may be compared, added, and
subtracted using the appropriate overloaded arithmetic operators.  
These operations may be used to construct values
representing any relative time (subject to precision and range
limitations), which is what is needed by an alarm's <CODE>set</CODE> method.
<P>
The alarm may be set multiple times with different arguments, in which
case the parameters of the most recent call to <CODE>set</CODE> are in effect.
Thus, once an alarm fires, it may be reused by calling <CODE>set</CODE> again.
<P>
An alarm may be unset by calling its method <CODE>unset()</CODE>.
<P>
<H3><A NAME="SEC420" HREF="manual_toc.html#SEC420">Custom Records (NOT YET IMPLEMENTED)</A></H3>
<P>
ILU generally supports a facility named
<I>custom records</I>.  This means that an application can declare that
the language-specific mapping of a particular record type
<VAR>ISL(A)</VAR> to <VAR>lang(A)</VAR> is to be overridden, and that
instead a specific type <VAR>X</VAR> will be used in this language to
represent values of <VAR>ISL(A)</VAR>.  In Perl, this
is done by simply replacing the generated class definition with a different
class definition.
<P>
For example, suppose we had the ISL record type
<PRE>
INTERFACE Ifc;
  ...
TYPE Foo = RECORD color : RGB-tuple, position : XY-pair END;
</PRE>
The normal mapping of <CODE>Ifc.Foo</CODE> to Perl would be to a hash reference
with two keys (<CODE>color</CODE>, and <CODE>position</CODE>.
To override this, simply define a new class <CODE>MyFoo</CODE> in your
application that is implemented as a blessed reference to an array
including these keys which has a method <CODE>ilu_record_init</CODE>.  Then
call <CODE>ILU-&#62;RegisterCustomRecord( 'Ifc.Foo' =&#62; 'MyFoo')</CODE>.
Subsequently, whenever an <CODE>Ifc.Foo</CODE> is unmarshalled, it will be
blessed into <CODE>MyFoo</CODE> and <CODE>$rcd-&#62;ilu_record_init()</CODE> will be
called. (It might be nice to additionally allow such custom records to
have getters and setters for their attributes.)
<P>
<H3><A NAME="SEC421" HREF="manual_toc.html#SEC421">String Binding Handle Formation</A></H3>
<P>
To use object tables properly, it is usually necessary for a client
program to create a surrogate instance for which the true instance does
not yet exist.  In Perl, this is done by creating a string
binding handle for the object, then calling
<CODE><CODE>ILU-&#62;ObjectOfSBH()</CODE></CODE> on that SBH.  String binding handles
may be formed by calling the function <CODE><CODE>ILU-&#62;FormSBH()</CODE></CODE>.
<P>
<H3><A NAME="SEC422" HREF="manual_toc.html#SEC422">Simple Binding</A></H3>
A true instance may be published with the simple binding service by calling its
method <CODE>ilu_publish()</CODE>.
A true instance may be unpublished by calling its method <CODE>ilu_withdraw()</CODE>.
<P>
A published ILU object may be obtained by calling
<CODE>ILU-&#62;LookupObject(sid, ih, cl)</CODE>,
where <CODE>sid</CODE> is object's server's server ID, <CODE>ih</CODE>
is the object's instance handle, and <CODE>cl</CODE> is its class.
<P>
<H3><A NAME="SEC423" HREF="manual_toc.html#SEC423">Principal Identities and Passports</A></H3>
<P>
An ILU passport (see section <A HREF="manual_15.html#SEC498">Security</A>) is represented in
Perl by an instance of the <CODE><CODE>ILU::Passport</CODE></CODE>
object type.  Instances of this type can be obtained by calling
<CODE><CODE>new ILU::Passport()</CODE></CODE>.  Please see the documentation of that
function for more information on the abilities of this object type.
<P>
The passport of the caller may be obtained in the true method by calling
the ILU runtime routine <CODE>ILU-&#62;CallerIdentity()</CODE>.  The
`native' passport may be obtained by calling
<CODE><CODE>ILU-&#62;GetPassport()</CODE></CODE>.  In the case of a local call, these two
passports may be the same object.  Passports are thread-local; that is,
an application may use a different passport in each thread.
<P>
<H2><A NAME="SEC424" HREF="manual_toc.html#SEC424">Building Perl/ILU Applications</A></H2>
<P>
<H3><A NAME="SEC425" HREF="manual_toc.html#SEC425">Stub Generation</A></H3>
To generate the Perl stubs from an ISL file,
use the program <CODE>perl-stubber</CODE>.
The file <TT>`<VAR>name</VAR>.pm'</TT> is generated from each ISL
<CODE>INTERFACE <VAR>name</VAR></CODE>.
<P>
In the future, it may be possible to have the information in
<TT>`<VAR>name</VAR>.pm'</TT> generated dynamically when needed, without
running the stubber separately.
<P>
<H3><A NAME="SEC426" HREF="manual_toc.html#SEC426">Implementing an ILU module in Perl</A></H3>
A Perl package that implements ILU objects of type
<VAR>T</VAR> defined in <CODE>INTERFACE <VAR>I</VAR></CODE> inherits from
<CODE><VAR>I</VAR>::<VAR>T</VAR></CODE>. If there is inheritance in the
ISL, and an implementation of a subtype wants to inherit from
an implementation of a supertype, the base class must be appear in
<CODE>@ISA</CODE> before <CODE><VAR>I</VAR>::<VAR>T</VAR></CODE>.
<P>
The constructor for the true object must call
<CODE>$self-&#62;ilu_init([<VAR>server</VAR>[,<VAR>handle</VAR>[,<VAR>implements</VAR>]]])</CODE>.
If <VAR>server</VAR> is present, it specifies the server to which this
object belongs, otherwise, a default value is used. If <VAR>handle</VAR>
is present, it is used as the instance handle, otherwise one is
invented. <VAR>implements</VAR> is only needed when, due to
implementation inheritance, the implementation class is derived not only
from the class it implements, but also from a base class of that class.
<P>
For example, objects for the ISL
<PRE>
INTERFACE j;

TYPE c1 = OBJECT METHODS one() END;
TYPE c2 = OBJECT METHODS two() END;
TYPE c3 = OBJECT SUPERTYPES c1, c2 END METHODS three() END;
</PRE>
could be implemented in Perl by
<PRE>
use ILU;
use J;

package C1;
@C1::ISA = qw(J::c1);

sub new {
   my ($class, $server, $ih) = @_;
   my $self = bless {};

   ... initialization ...
 
   $self-&#62;ilu_init($server, $ih);
}

sub one {
   ...
}

package C2;
@C2::ISA = qw(J::c1);

sub new {
  ...
}

sub two {
  ...
}

package C3;
@C3::ISA = qw(C1 C2 J::c3);

sub new {
   my ($class, $server, $ih) = @_;
   my $self = bless {};

   $self-&#62;ilu_init($server, $ih, 'J::c3');
}
</PRE>
In this case <CODE>C3</CODE>'s method <CODE>one</CODE> is implemented by
<CODE>C1::one</CODE> and <CODE>C3</CODE>'s method <CODE>two</CODE> is implemented by
<CODE>C2::two</CODE>.
<P>
<H4><A NAME="SEC427" HREF="manual_toc.html#SEC427">Exporting Objects</A></H4>
An object can be exported in one of three ways:
<OL>
<LI>
The object's string binding handle may be obtained by calling its
method <CODE>ilu_sbh()</CODE> and communicating this somehow to a client,
who then turns the handle back into an object by calling
<CODE>ILU-&#62;ObjectOfSBH(cl, sbh)</CODE>.
<LI>
The object may be published using the simple binding service
by calling its method <CODE>ilu_publish()</CODE>.
In order for this to be effective, the object must have a well-known
object ID, or the object ID must be communicated to clients, so clients can
know what to pass to <CODE>ILU-&#62;LookupObject</CODE>.
The object ID is the combination of the object's instance handle and
its server's server ID.
<LI>
The object may be returned by a method or passed back in a method's
<CODE>INOUT</CODE> or <CODE>OUT</CODE> parameter.
</OL>
<P>
<H3><A NAME="SEC428" HREF="manual_toc.html#SEC428">Using an ILU module in Perl</A></H3>
The ILU runtime interface is in the Perl module
<CODE>ILU</CODE>.
Perl definitions for ISL
<CODE>INTERFACE <VAR>I</VAR></CODE> are in the Perl module
<CODE><VAR>I</VAR></CODE>.
As with any other modules in Perl, the functionality in this
module is added to your program using the <CODE>use</CODE> statement.
<P>
A client program may create an ILU object in one of three ways:
<OL>
<LI>
Knowing the string binding handle <CODE>sbh</CODE> and class <CODE>cl</CODE> of an
object,
call <CODE>ILU-&#62;ObjectOfSBH(cl, sbh)</CODE> which returns an instance of that class.
For example, to obtain an instance of ISL type <CODE>Square</CODE> from
<CODE>INTERFACE Shapes</CODE>
whose string binding handle is <CODE>$sbh</CODE>,
one would call <CODE>ILU-&#62;ObjectOfSBH('Shapes::Square', $sbh)</CODE>.
<LI>
Knowing the object ID <CODE>(sid, ih)</CODE> and class <CODE>cl</CODE> of an object that
has been published using the simple binding service,
call <CODE>ILU-&#62;LookupObject(sid, ih, cl)</CODE> which returns an instance of that class
(or <CODE>undef</CODE> if the lookup fails).
<LI>
Receive an instance as a result value from a method call that returns an
object type or has an object type as an <CODE>INOUT</CODE> or <CODE>OUT</CODE> parameter.
</OL>
<P>
<H3><A NAME="SEC429" HREF="manual_toc.html#SEC429">CORBA Support in Perl</A></H3>
<P>
Perl <CODE>CORBA</CODE> module contains support for the classes
<CODE><CODE>CORBA::ORB</CODE></CODE> and <CODE><CODE>CORBA::Object</CODE></CODE>, and the
<CODE><CODE>CORBA::ORB_init()</CODE></CODE> function, which provide some
compatability with the standard CORBA interfaces. See the
Perl/ILU API Reference for more information on these classes.
<P>
<H2><A NAME="SEC430" HREF="manual_toc.html#SEC430">Perl/ILU API Reference</A></H2>
<P>
<H3><A NAME="SEC431" HREF="manual_toc.html#SEC431">Identifiers in Module <CODE>ILU</CODE></A></H3>
<P>
The following functions are meant to be called as
<CODE>ILU-&#62;TheFunction(args)</CODE>. That is, they take an extra first
argument which is ignored, allowing the use of the method invocation
syntax. (This may be changed in the future.)
<P>
<A NAME="IDX659"></A>
<A NAME="IDX660"></A>
<U>Function:</U> <B>CallerIdentity</B> <I>()</I><P>
<P>
Returns the passport containing identities of the caller.  This routine is only valid inside the code of a true method.
<P>
<A NAME="IDX661"></A>
<A NAME="IDX662"></A>
<U>Function:</U> <B>DoSoon</B> <I>(<VAR>FUNCTION</VAR>, <VAR>ARGS-TUPLE</VAR>, <VAR>STRING-DESCRIPTION</VAR>)</I><P>
<P>
Causes the function <VAR>FUNCTION</VAR> to be run with args <VAR>ARGS-TUPLE</VAR>
to be run at some point in the future, when the system finds it to be convenient.
In the threaded world, a new thread is forked to run the function; in the non-threaded
world, the function is executed at some point by the event loop as a background
task.
<P>
<A NAME="IDX663"></A>
<A NAME="IDX664"></A>
<U>Constant:</U> <B>FALSE</B><P>
<P>
A value which evaluates to Perl boolean False.
<P>
<A NAME="IDX665"></A>
<A NAME="IDX666"></A>
<U>Function:</U> <B>FormSBH</B> <I>(sid, ih, type, pinfo, ...)</I><P>
<P>
Forms a valid ILU string binding handle from the arguments and
returns it.  The <VAR>sid</VAR> and <VAR>ih</VAR> arguments are strings
containing the server ID and instance handle for the desired instance.
The <VAR>type</VAR> argument should be the Perl class for the
most specific object type of the desired object.  The <VAR>pinfo</VAR> is
a string containing the protocol information describing the object
implementation's preferred communication protocol.  The remaining
arguments are strings specifying the transport stack needed to connect
to the implementation. The elements of the protocol and transport info
strings are separated by underscores.
<P>
For instance, to create a string binding handle for an instance of type
<CODE>Foo.Bar</CODE>, with server id <CODE>"some-server-id"</CODE> and instance
handle <CODE>"some-instance-handle"</CODE>, exported via <CODE>Sun RPC</CODE>,
version 2, with program number 1000007, version 3, via <CODE>TCP/IP</CODE>
from host <CODE>"foobar.somewhere.com"</CODE>, port 3456, we'd say<BR> <CODE>sbh
= ILU-&#62;FormSBH('some-server-id', 'some-instance-handle','Foo::Bar',<BR>
'sunrpc_2_1000007_3, 'sunrpcrm', 'tcp_foobar_somewhere_com_3456')</CODE><BR>
Note that use of this procedure requires some specialized knowledge,
such as knowing that use of <CODE>Sun RPC</CODE> also requires use of the
<CODE>Sun RPC</CODE> record-marking transport layer when used over
<CODE>TCP/IP</CODE>.
<P>
<A NAME="IDX667"></A>
<A NAME="IDX668"></A>
<U>Constant:</U> <B>FineTimeRate</B><P>
<P>
The precision of type <CODE>ilu_FineTime</CODE> in seconds is the reciprocal of
this constant.
<P>
<A NAME="IDX669"></A>
<A NAME="IDX670"></A>
<U>Function:</U> <B>GetPassport</B> <I>()</I><P>
<P>
Returns the current passport for this thread.  See also <CODE><CODE>SetPassport()</CODE></CODE>.
<P>
<A NAME="IDX671"></A>
<A NAME="IDX672"></A>
<U>Function:</U> <B>GetPipeline</B> <I>()</I><P>
<P>
Returns the current pipeline context for this thread.  See also <CODE><CODE>CreatePipeline()</CODE></CODE> and <CODE><CODE>SetPipeline()</CODE></CODE>.
<P>
<A NAME="IDX673"></A>
<A NAME="IDX674"></A>
<U>Function:</U> <B>GetSerializer</B> <I>()</I><P>
<P>
Returns the current serialization context for this thread.  See also the <CODE><CODE>createSerializer()</CODE></CODE> method on the <CODE><CODE>ilu_Server</CODE></CODE> class, and the <CODE><CODE>SetSerializer()</CODE></CODE> function.
<P>
<A NAME="IDX675"></A>
<A NAME="IDX676"></A>
<U>Function:</U> <B>LookupObject</B> <I>(sid, ih, cl)</I><P>
<P>
Returns the object with object server ID <VAR>sid</VAR>, object instance handle <VAR>ih</VAR>,
and Perl package name <CODE>cl</CODE>,
assuming it was previously published using the simple binding service.
If the lookup fails, <CODE>None</CODE> is returned.
<P>
<A NAME="IDX677"></A>
<A NAME="IDX678"></A>
<U>Function:</U> <B>ObjectOfSBH</B> <I>(cl, sbh)</I><P>
<P>
Returns the object corresponding to the Perl package name <VAR>cl</VAR>
and string binding handle <VAR>sbh</VAR>.
<P>
<A NAME="IDX679"></A>
<A NAME="IDX680"></A>
<U>Function:</U> <B>ParseSBH</B> <I>(sbh)</I><P>
<P>
Returns the the object id and contact info corresponding to the string
binding handle <VAR>sbh</VAR> as a list 
<CODE>(<VAR>ih</VAR>, <VAR>sid</VAR>, <VAR>mstid</VAR>, <VAR>cinfo</VAR>)</CODE>.
<VAR>ih</VAR> is instance handle, <VAR>sid</VAR> the server ID, 
<VAR>mstid</VAR> the most specific type id and  <VAR>cinfo</VAR> the
contact info encoded as a string.
<P>
<A NAME="IDX681"></A>
<A NAME="IDX682"></A>
<U>Function:</U> <B>RegisterCustomSurrogate</B> <I>(class)</I><P>
<P>
NOT YET IMPLEMENTED
<P>
Registers <VAR>class</VAR> as the object type to create when receiving a surrogate of the
type indicated by the <CODE>_IluClass</CODE> field of <VAR>class</VAR>.  <VAR>class</VAR> must
be a subtype of the default surrogate type for this ILU type.  This allows custom
surrogates, with implications for caching and other object-type-specific functions.
<P>
<A NAME="IDX683"></A>
<A NAME="IDX684"></A>
<U>Function:</U> <B>RegisterInputHandler</B> <I>(fileno, handler_fn, ...)</I><P>
<P>
Sets up <VAR>handler_fn</VAR> to be called every time input is availabe
on the file corresponding to fileno. (You can get the file number of a
file handle with <CODE>fileno(HANDLE)</CODE>. handler_fn is a reference to a
subroutine or anonymous subroutine. This is useful for implementing a
server that also responds to commands typed to its standard input, for
example.  Passing a value of <CODE>undef</CODE> for the
<VAR>handler_fn</VAR> removes the handler.  Any additional arguments will
be passed to the handler function
<P>
<A NAME="IDX685"></A>
<A NAME="IDX686"></A>
<U>Function:</U> <B>SetCalloutExceptionHandler</B> <I>(handler-fn)</I><P>
<P>
NOT YET IMPLEMENTED
<P>
This function can be used to define a function <VAR>handler-fn</VAR> which is called when an internal Perl
exception is signalled in code called from the ILU C code.  The handler function receives
four arguments:  a string indicating where in the ILU runtime the exception was encountered, the exception
type, the exception value, and a traceback object.  This function is typically used to note the exception
to a file or stderr; see the example usage in <TT>`<VAR>ILUSRC</VAR>/runtime/python/iluRt.py'</TT>.  If a parameter
of <CODE>None</CODE> is passed to <CODE>SetCalloutExceptionHandler</CODE>, it cancels any handler function in use,
and a default built-in one is used.
<P>
<A NAME="IDX687"></A>
<A NAME="IDX688"></A>
<U>Function:</U> <B>SetDebugLevel</B> <I>(flags)</I><P>
<P>
Sets the ILU kernel debugging flags according to its
argumentSee the Debugging section of the ILU Manual for more information
on the argument.
<P>
<A NAME="IDX689"></A>
<A NAME="IDX690"></A>
<U>Function:</U> <B>SetDebugLevelViaString</B> <I>(switches)</I><P>
<P>
Sets the ILU kernel debugging flags according to its argument,
which is a colon-separated list of debug switches.See the Debugging
section of the ILU Manual for more information on these switches.
<P>
<A NAME="IDX691"></A>
<A NAME="IDX692"></A>
<U>Function:</U> <B>SetPassport</B> <I>(passport)</I><P>
<P>
Sets the current passport identity for this thread, and returns the passport active before this call.
Either of these can be <CODE>None</CODE>.  Also see the function <CODE><CODE>CreatePassport</CODE></CODE>,
and the function <CODE><CODE>GetPassport</CODE></CODE>.
<P>
<A NAME="IDX693"></A>
<A NAME="IDX694"></A>
<U>Function:</U> <B>SetPipeline</B> <I>(pipeline)</I><P>
<P>
Sets the current pipelining context for this thread, and returns the context active before this call.
Either of these can be <CODE>None</CODE>.  Also see the function <CODE><CODE>CreatePipeline</CODE></CODE>,
and the function <CODE><CODE>GetPipeline</CODE></CODE>.
<P>
<A NAME="IDX695"></A>
<A NAME="IDX696"></A>
<U>Function:</U> <B>SetSerializer</B> <I>(serializer)</I><P>
<P>
Sets the current serialization context for this thread, and returns the context active before this call.
Either of these can be <CODE>None</CODE>.  Also see the <CODE><CODE>createSerializer</CODE></CODE> method on
the class <CODE><CODE>ilu_Server</CODE></CODE>, and the function <CODE><CODE>GetSerializer</CODE></CODE>.
<P>
<A NAME="IDX697"></A>
<A NAME="IDX698"></A>
<U>Function:</U> <B>ThreadedOperation</B> <I>()</I><P>
<P>
Enables thread use in both the ILU kernel and the
ILU/Perl runtime.  This routine should be called in a begin
block before calling <CODE>use</CODE> for any stubber-created modules,
and before any other ILU calls are made.
<P>
<A NAME="IDX699"></A>
<A NAME="IDX700"></A>
<U>Constant:</U> <B>Version</B><P>
<P>
The ILU version string.
<P>
<A NAME="IDX701"></A>
<A NAME="IDX702"></A>
<U>Class:</U> <B>Object</B> <I>(ILU::MainLoop)</I><P>
A type representing an ILU server. It supports the following methods:
<P>
<UL>
<P>
<LI><CODE>new ()</CODE> - creates a new object of type <CODE>ILU::MainLoop</CODE>
<LI><CODE>run ()</CODE> - Runs the loop
<LI><CODE>exit ()</CODE> - Causes the specified loop to exit.
<P>
</UL>
<P>
<A NAME="IDX703"></A>
<A NAME="IDX704"></A>
<U>Class:</U> <B>Object</B> <I>(ILU::Server)</I><P>
A type representing an ILU server. It supports the following methods:
<P>
<UL>
<P>
<LI><CODE>default ILU::Server ()</CODE> - returns the default server.
<LI><CODE>new ILU::Server( [serverID [transport [protocol [objtable]]]] )</CODE>
<P>
Create an <CODE>ILU::Server</CODE> object with the specified serverID,
transport, and protocol.  If <VAR>serverID</VAR> is unspecified or
<CODE>undef</CODE>, an identifier will be invented automatically.  If
transport or protocol are unspecified or <CODE>undef</CODE>, they will default
to <CODE>['sunrpcrm', 'tcp_0_0']</CODE> and <CODE>'sunrpc'</CODE>, respectively.
(Other combinations that would work are transport of <CODE>['tcp_0_0']</CODE>
and protocol of <CODE>'iiop_1_0_1'</CODE>, transport of <CODE>['sunrpcrm',
'tcp_0_0']</CODE> and protocol of <CODE>'courier'</CODE>, and transport of
<CODE>['tcp_0_0']</CODE> and protocol of <CODE>'http'</CODE>, depending on the
configuration of your ILU system.)  The first time a server is
created, the server so created becomes the default server.  If there is
no default server when one is required, one will be created using
default parameters and a message will be issued on stderr.  The
<VAR>objtable</VAR> argument allows specification of a callback function
for creating true instances on demand.  The callback function should
take one argument, a string, which is the object ID of the instance to
be created, and return a true instance.
<LI><CODE><CODE>add_port (<VAR>TRANSPORT</VAR>, <VAR>PROTOCOL</VAR>)</CODE></CODE> - adds
a port with the specified <VAR>TRANSPORT</VAR> and <VAR>PROTOCOL</VAR>
(described above) to the server instance.
<LI><CODE><CODE>id ()</CODE></CODE> - returns the string identifier of the server.
</UL>
<P>
<A NAME="IDX705"></A>
<A NAME="IDX706"></A>
<U>Class:</U> <B>Object</B> <I>(ILU::Passport)</I><P>
<P>
The <CODE><CODE>ILU::Passport</CODE></CODE> object is used to provide a sense of identity
in the ILU system.  It can hold any number of different identities,
each of which is represented with an appropriate data structure that varies
from identity type to identity type.
<P>
The <CODE><CODE>ILU::Passport</CODE></CODE> object type has the following methods:
<P>
<UL>
<P>
<LI><CODE><CODE>new</CODE></CODE> - creates and returns an empty passport.
<P>
<LI><CODE><CODE>lookupIdentity (<VAR>IDENTITY-TYPE-NAME</VAR>)</CODE></CODE> - returns
the data structure for the specified identity, if the passport contains one;
Returns <CODE>None</CODE> otherwise.  Raises <CODE>ilu.IluGeneralError</CODE> if the
named identity type does not exist.  The identity type <CODE><CODE>'ConnectionIdentity'</CODE></CODE>
is always supported; the identity type <CODE><CODE>'SunRPCAuthUnixIdentity'</CODE></CODE>
will be supported if support for the <CODE>sunrpc</CODE> protocol has been configured
into ILU.
<LI><CODE><CODE>addSunRPCAuthUnix (<VAR>HOSTNAME</VAR>, <VAR>UID</VAR>, <VAR>GID</VAR>, <VAR>GROUPS</VAR>)</CODE></CODE> -
adds an identity of type <CODE><CODE>'SunRPCAuthUnixIdentity'</CODE></CODE> to the passport
with the specified <VAR>HOSTNAME</VAR>, <VAR>UID</VAR>, <VAR>GID</VAR>, and
<VAR>GROUPS</VAR> (the remaining parameters).
See Appendix A of RFC 1831 at <A HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1831.txt"><TT>http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1831.txt</TT></A> for details on the meaning of these parameters.  This method will only be available if support for
the <CODE>sunrpc</CODE> protocol has been configured into ILU.
</UL>
<P>
<A NAME="IDX707"></A>
<A NAME="IDX708"></A>
<U>Class:</U> <B>Object</B> <I>(ILU::Pipeline)</I><P>
<P>
The <CODE><CODE>ilu_Pipeline</CODE></CODE> object is used to allow
multiple requests to be outstanding on non-concurrent protocol streams.
<P>
The <CODE><CODE>ILU::Pipeline</CODE></CODE> object type has the following method:
<P>
<UL>
<P>
<LI><CODE><CODE>new</CODE></CODE> - creates and returns a pipeline object.
</UL>
<P>
<A NAME="IDX709"></A>
<A NAME="IDX710"></A>
<U>Class:</U> <B>Object</B> <I>(ILU::Serializer)</I><P>
<P>
The <CODE><CODE>ilu_Serializer</CODE></CODE> object is used to ensure that
multiple requests are received by the server in the same order
that the client makes them.
<P>
The <CODE><CODE>ILU::Serializer</CODE></CODE> object type has the following method:
<P>
<UL>
<P>
<LI><CODE><CODE>new</CODE></CODE> - creates and returns a serializer object.
</UL>
<P>
<H3><A NAME="SEC432" HREF="manual_toc.html#SEC432">Identifiers from the <CODE>CORBA</CODE> Module</A></H3>
<P>
<A NAME="IDX711"></A>
<A NAME="IDX712"></A>
<U>Variable:</U> <B>%CORBA::InitialReferences</B><P>
A hash with string keys, and values of type
<CODE><CODE>CORBA::Object</CODE></CODE>.  It is used to resolve strings passed as
parameters to
<CODE><CODE>CORBA::ORB::resolve_initial_references()</CODE></CODE>.  The
following names are supported automatically by Perl
runtime:
<UL>
<LI><B>NameService</B><BR>
If the environment variable <CODE>ILU_COS_NAMING_IOR</CODE> is bound to a string IOR
for a OMG IDL <CODE>CosNaming::NamingContext</CODE> object instance,
the Perl runtime will attempt to create a surrogate for that
instance locally, ping it, and if successful will bind it to the string <CODE>"NameService"</CODE>.
</UL>
<P>
<A NAME="IDX713"></A>
<A NAME="IDX714"></A>
<U>Class:</U> <B>Object</B> <I>(CORBA::Object)</I><P>
A type which all object types defined in OMG IDL, or inheriting
from <CODE>ilu.CORBA-Object</CODE> in ISL, participate in.  It supports
the following methods:
<UL>
<LI><CODE>_is_a(<VAR>type_uid</VAR>)</CODE> - returns <CODE>True</CODE> if the object is
of the specified type, <CODE>False</CODE> otherwise; raises
<CODE>ILU::IluUnknownTypeIDError</CODE> if the <VAR>type_uid</VAR> is unknown in
this address space;
<A NAME="IDX716"></A>
<A NAME="IDX715"></A>
<LI><CODE>_is_nil()</CODE> - returns <CODE>False</CODE>; raises <CODE>TypeError</CODE> if called
via <CODE><CODE>Corba::Object::_is_nil()</CODE></CODE> on a non-Perl-object type;
<A NAME="IDX718"></A>
<A NAME="IDX717"></A>
<LI><CODE>_non_existent()</CODE> - returns the logical inverse of the result of calling
<CODE>ilu.PingObject()</CODE> on the object;
<A NAME="IDX720"></A>
<A NAME="IDX719"></A>
<LI><CODE>_is_equivalent(<VAR>other</VAR>)</CODE> - returns the result of comparing
<VAR>self</VAR> and <VAR>other</VAR> with the Perl <CODE>==</CODE> operator;
<A NAME="IDX722"></A>
<A NAME="IDX721"></A>
<A NAME="IDX723"></A>
<A NAME="IDX724"></A>
<LI><CODE>_duplicate()</CODE> - does nothing, returns <VAR>self</VAR>;
<A NAME="IDX725"></A>
<A NAME="IDX726"></A>
<LI><CODE>_release()</CODE> - does nothing, returns nothing;
<A NAME="IDX727"></A>
<A NAME="IDX728"></A>
<LI><CODE>_hash(<VAR>max_value</VAR>)</CODE> - returns <CODE>(hash(<VAR>self</VAR>) % (<VAR>max_value</VAR> + 1))</CODE>;
<A NAME="IDX729"></A>
<A NAME="IDX730"></A>
<LI><CODE>_get_implementation()</CODE> - raises <CODE><CODE>IluUnimplementedMethodError</CODE></CODE>;
<A NAME="IDX731"></A>
<A NAME="IDX732"></A>
<LI><CODE>_get_interface()</CODE> - raises <CODE><CODE>IluUnimplementedMethodError</CODE></CODE>;
</UL>
The <CODE><CODE>CORBA::Object</CODE></CODE> class is actually implemented in <CODE><CODE>ILU::CORBA_Object</CODE></CODE>,
so all classes which inherit from <CODE><CODE>ILU::CORBA_Object</CODE></CODE> will have access to these
methods.
<P>
<A NAME="IDX733"></A>
<A NAME="IDX734"></A>
<U>Class:</U> <B>ORB</B><P>
The general class for manipulating the object request broker.  There is typically
only one instance of this class per address space.  It is retrieved with the
function <CODE><CODE>CORBA::ORB_init()</CODE></CODE>; it supports the following methods:
<UL>
<LI><CODE>object_to_string(<VAR>instance</VAR>)</CODE> - returns
a string which can be used in a subsequent <CODE><CODE>string_to_object()</CODE></CODE> call;
<A NAME="IDX735"></A>
<LI><CODE>string_to_object(<VAR>string</VAR>)</CODE> - if the specified <VAR>string</VAR>
is well formed and specifies an object, the object is created locally and a reference is returned; the
reference may be to a true instance if the string names a true instance; if the string
is poorly formed, the Perl exception <CODE><CODE>ilu.IluGeneralError</CODE></CODE>
is raised.  This method does not test for the existence of the instance.
<A NAME="IDX736"></A>
<LI><CODE>resolve_initial_references(<VAR>string</VAR>)</CODE> - If the
<VAR>string</VAR> argument is bound in the dictionary <CODE><CODE>%CORBA::InitialReferences</CODE></CODE>,
the value is returned.  Otherwise, the exception <CODE><CODE>CORBA::InvalidName</CODE></CODE> is raised.
See the documentation of <CODE><CODE>%CORBA::InitialReferences</CODE></CODE> for a listing of the
names that are bound automatically, if any.
<A NAME="IDX737"></A>
</UL>
<P>
<A NAME="IDX738"></A>
<A NAME="IDX739"></A>
<U>Function:</U> <B>ORB_init</B> <I>(<VAR>argv</VAR>=(), <VAR>orb_id</VAR>='ilu')</I><P>
Returns an instance of <CODE><CODE>CORBA::ORB</CODE></CODE> with the specified <VAR>orb_id</VAR> (currently
only the ORB ID <CODE>'ilu'</CODE> is supported).  The arguments which may be passed
in via <VAR>argv</VAR> are ignored.
<P>
<H3><A NAME="SEC433" HREF="manual_toc.html#SEC433">Methods and Attributes of ILU Objects</A></H3>
<P>
<UL>
<LI>
<CODE>ilu_object_id()</CODE> returns the object ID of the object.
<A NAME="IDX740"></A>
<LI>
<CODE>ilu_publish()</CODE> publishes the object using the simple binding service.
<A NAME="IDX741"></A>
<LI>
<CODE>ilu_sbh()</CODE> returns the object's string binding handle.
<A NAME="IDX742"></A>
<LI>
<CODE>ilu_type_id()</CODE> returns the unique type identifier of the
object's ILU type.
<A NAME="IDX743"></A>
<LI>
<CODE>ilu_type_name()</CODE> returns the type name of the object's ILU type.
<A NAME="IDX744"></A>
<LI>
<CODE>ilu_withdraw()</CODE> undoes the effect of ilu_publish().
<A NAME="IDX745"></A>
</UL>
<P>
<P>Go to the <A HREF="manual_9.html">previous</A>, <A HREF="manual_11.html">next</A> section.<P>
